---
title: "Mobius Regression of Earthquake Moment Tensors"
subtitle: "Shallow Earthquakes Regions 2 - 4"
format:
  pdf:
    toc: true
    number-sections: true
    fig-width: 6.5
---

# Preparation
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(ggplot2)
library(dplyr)
library(GGally)
library(patchwork)
library(sphm)
packageVersion("sphm")
```

## Raw Data
This data is copied directly from Hejrani et al (2017) Table 1.

```{r}
raw=read.table(file="./papua20240709.csv",
               header=T,sep=",", numerals = "warn.loss",
               colClasses = c(Origin.Time = "character"))
head(raw) %>%
  mutate(Origin.Time = paste0(substr(`Origin.Time`, 1, 6),"..")) %>%
  rename(Lon = Longitude,
         Lat = Latitude) %>%
  knitr::kable() %>%
  kableExtra::kable_styling(font_size = 8)
```

In this raw data:

+ `Origin.Time`. Hejrani references the GCMT project for origin times. Though not explicitly in Hejrani et al (2017), it seems this column is the format that GCMT uses for modern earthquakes, which is XYYYYMMDDhhmmZ where X is the type of data used, Z is for distinguishing events at the same time (day?) and the stuff in between ti time.
+ `Number` relates uniquely to increasing origin time.
+ `Lon` and `Lat` are the Longitude and Latitude of the earthquake
+ `Depth` is the depth (in kilometres) of the earthquake
+ `M**` are scaled elements of the earthquake moment tensors where `r`, `t`, `f` represent basis directions.
+ `Mw * 10^Exp` is a magnitude.
+ `Dcper` is related to how close the earthquake is a to a pure double-couple.

For later lets record the names of the `M**` columns in the same order as the symmetric-matrix vectorisation function `vech`:

```{r}
elementnames <- c("Mrr", "Mrt", "Mrf",
                  "Mtt", "Mtf",
                  "Mff")
```

## Transform to $S^4$
### Enforce Trace=0 and Scale=1
The moment tensors have traces that are nearly 0.

```{r}
traces <- rowSums(raw[, c("Mrr", "Mtt", "Mff")])
traces %>%
  tibble::enframe(value = "trace") %>%
  ggplot() +
  geom_histogram(aes(x = trace), bins = 30) +
  geom_rug(aes(x = trace))
```

Here I'll make the trace exactly zero.

```{r}
stddf <- raw %>%
  mutate(Mff = -Mrr - Mtt)
```

Now we scale the moment tensors to have a Frobenius norm of 1. The function `gettr2()` below is a fast way to compute the square of the Frobenius norm without winding the 6 `M**` columns up into individual 3 x 3 matrices.
```{r tr2}
gettr2 <- function(ms){
  I2 <- ms[, 1] * ms[, 4] + ms[, 4] * ms[, 6] + ms[,1] * ms[,6] -
    ms[, 2]^2 - ms[, 5]^2 - ms[,3]^2
  I1 <- ms[, 1] + ms[, 4] + ms[, 6] #trace
  tr2 <- I1^2 - 2*I2
  return(tr2)
}
Fnorm <- sqrt(gettr2(stddf[, elementnames]))
stddf <- stddf %>%
  mutate(Fnorm = Fnorm) %>%
  mutate(across(starts_with("M"), ~.x/Fnorm))
```

Lets verify the result of these transformations on the first earthquake.

```{r}
elementvalues <- unlist(stddf[1, elementnames])
tmpM <- matrix(NA, 3, 3)
tmpM[lower.tri(tmpM, diag = TRUE)] <- elementvalues
tmpM[upper.tri(tmpM)] <- t(tmpM)[upper.tri(tmpM)]
colnames(tmpM) <- rownames(tmpM) <- c("r", "t", "f")

elementvalues
tmpM
sqrt(sum(tmpM^2))
sum(diag(tmpM))
```

The trace and norm are exactly 0 and 1 as desired.

### Moment Tensors as Unit Vectors in $R^5$
The diagonal elements must sum to zero, which puts them on a plane through the origin.
I'll use the Helmert submatrix to express these diagonal elements with respect to an orthonormal basis on this plane. The plane is two dimensions, so I'll call these new coordinates `s1` and `s2`.

```{r}
H <- rbind(c(1,-1, 0), c(1,1,-2))
H <- H/sqrt(rowSums(H^2))
diagproj <- t(H %*% t(stddf[, c("Mrr", "Mtt", "Mff")]))
colnames(diagproj) <- c("s1", "s2")
```

I'll scale the off diagonal elements by $\sqrt{2}$ because off-diagonal elements are counted twice in the Frobenius norm.

```{r}
offdiag <- stddf %>%
  mutate(sMrt = sqrt(2) * Mrt,
         sMrf = sqrt(2) * Mrf,
         sMtf = sqrt(2) * Mtf) %>%
  select(sMrt, sMrf, sMtf)
```

Combined these are unit vectors in $R^5$
```{r}
sqrt(rowSums(cbind(diagproj, offdiag)^2))
```

Lets add these unit vectors into full data frame
```{r}
s4df <- bind_cols(diagproj, offdiag, raw)
```

## Hejrani et al (2017)'s Regions
Here I have captured the regions from Fig 16 of Hejrani et al (2017) by visual assessment.
```{r}
library(sf)
ptmatrix <- function(xmin, xmax, ymin, ymax){
  matrix(c(xmin, ymax,   
           xmax, ymax,
           xmax, ymin,
           xmin, ymin,
           xmin, ymax), byrow = TRUE, ncol = 2)
}

regions <- st_sfc(st_polygon(list(ptmatrix(141, 144, -4, -2))),
                  st_polygon(list(ptmatrix(144, 147.3, -4, -2))),
                  st_polygon(list(ptmatrix(147.3, 150.3, -4, -2.5))),
                  st_polygon(list(ptmatrix(150.3, 152.5, -4.1, -3))),
                  st_polygon(list(ptmatrix(146.1, 151.5, -7.1, -5.7))),
                  st_polygon(list(ptmatrix(151.5, 153.5, -6.8, -4.7))),
                  st_polygon(list(ptmatrix(153.5, 156.7, -8.5, -5))),
                  st_polygon(list(ptmatrix(156.7, 159, -10, -8))),
       crs = 4326)
regions <- st_sf(region = factor(1:8, ordered = TRUE), geom = regions)
```

## Keep Only Shallow Earthquakes in Regions 2-4
The below keeps only earthquakes in regions 2 to 4 with depth smaller than 20.
It assumes that the longitude and latitude are follow the GPS coordinate system.

```{r}
s4df <- sf::st_as_sf(s4df, coords = c("Longitude", "Latitude"), remove = FALSE)
sf::st_crs(s4df) <- 4326
s4df <- st_intersection(s4df, regions) 
s4df <- mutate(s4df, region = as.factor(region))
s4df <- s4df %>% 
  filter(region %in% 2:4) %>%
  filter(Depth <= 20)
nrow(s4df)
```

## $S^4$ Plot Helpers
Below makes circles for plotting the edge of S^4 later.

```{r}
# Create data for the unit circle
theta <- seq(0, 2 * pi, length.out = 100)
circle_df <- data.frame(x = cos(theta), y = sin(theta))
colpairs <- #combn(paste0("Y", 1:5), 2, simplify = FALSE)
expand.grid(paste0("Y", 1:5), paste0("Y", 1:5)) %>%
  filter(Var1 != Var2) %>%
  mutate(Var1 = as.character(Var1), Var2 = as.character(Var2)) %>%
  rowwise() %>%
  mutate(pair = list(c(Var1, Var2))) %>%
  select(pair) %>%
  unlist(recursive = FALSE)
pair_dfs <- lapply(colpairs, function(pair) {
  Aname <- pair[1]
  Bname <- pair[2]
  circle_df %>%
    rename(A = x, B = y) %>%
    mutate(pair1=Aname,
           pair2=Bname,
           pair = paste(pair, collapse = "-"))
})
circle_df_long <- bind_rows(pair_dfs)
```

And the following is useful for orthogonal projection of locations on to pairs of axes:

```{r}
pivot_coordpairs <- function(df, 
                             coordnames = paste0("Y",1:5),
                             colpairs = combn(coordnames, 2, simplify = FALSE)){
  pair_dfs <- lapply(colpairs, function(pair) {
    Aname <- pair[1]
    Bname <- pair[2]
    df %>%
      # copy pair values
      mutate(A = .data[[Aname]],
             B = .data[[Bname]]) %>%
      mutate(pair1=Aname,
             pair2=Bname,
             pair = paste(pair, collapse = "-"))
  })
  pairsdf <- bind_rows(pair_dfs)
  attr(pairsdf, "coordnames") <- coordnames
  pairsdf
}
pairedplotggprep <- function(df){
  # rename circle_df_long to coordnames
  dict <- attr(df, "coordnames")
  names(dict) <-  paste0("Y", 1:length(dict))
  circle_df_long <- circle_df_long %>%
    mutate(
      pair1 = dict[pair1],
      pair2 = dict[pair2],
      pair = paste0(pair1,"-",pair2))
  
  # nicer strip labels
  label_map <- c(
    s1 = "(Mrr - Mtt)/sqrt(2)",
    s2 = "(Mrr + Mtt - 2*Mff)/sqrt(6)",
    sMrf = "Mrf / sqrt(2)",
    sMrt = "Mrt / sqrt(2)",
    sMtf = "Mtf / sqrt(2)",
    Y1 = "Y1",
    Y2 = "Y2",
    Y3 = "Y3",
    Y4 = "Y4",
    Y5 = "Y5",
    r1 = "r1",
    r2 = "r2",
    r3 = "r3",
    r4 = "r4"
  )
  
  #now do plotting prep
  ggplot(data = df, mapping = aes(x=A, y=B)) +
  facet_grid(vars(pair2),
             vars(pair1),
             switch = "both",
             labeller = as_labeller(label_map, label_parsed)) +
  geom_path(data = ~(circle_df_long %>% filter(pair %in% .x$pair)),
            mapping = aes(x=A,y=B),
            inherit.aes = FALSE,
            color = "grey") +
  coord_fixed(xlim = c(-1.01,1.01), ylim = c(-1.01,1.01), expand = FALSE) +
  theme_minimal() +
  theme(strip.text.y = element_text(angle = 90),
        strip.placement = "outside",
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_line(arrow = grid::arrow(type = "closed", 
                                                     angle = 10, 
                                                length = unit(10, "points")),
                                 linewidth = 0.2),
        panel.grid = element_blank(),
        legend.position = "bottom")
}
```


## Pairwise Projections of Earthquake Moment Tensors (SI Figure)
```{r}
#| fig.width: 12
#| fig.height: 13
s4df %>%
  pivot_coordpairs(coordnames = c("s1", "s2", "sMrf", "sMrt", "sMtf")) %>%
  pairedplotggprep() +
  geom_point(aes(col = Longitude)) +
  scale_shape_manual(guide = "none", values = c(4, 16)) +
  scale_color_viridis_c()
ggsave("earthq_mtensors.pdf", width = 12, height = 13)
```

## Additional Covariates
For each earthquake we find the distance to the BSSL and also the direction (up to $\pm \pi$) of the fault at this closest point.
This direction is known as the strike in seismology (For BSSL, the fault plane is vertical so strike may as well be below $\pi$).

### Distance to BSSL
Plate information was obtained from github `https://github.com/fraxen/tectonicplates`.

```{r}
#| eval: false
tmp <- paste0("https://github.com/fraxen/tectonicplates/raw/refs/heads/master/PB2002_boundaries.", c("dbf", "prj", "sbn", "sbx", "shp", "shp.xml", "shx")) |>
  lapply(function(x){download.file(x, basename(x))})
```

```{r}
library(sf)
library("rnaturalearth")
world <- ne_countries(scale = "medium", returnclass = "sf")
tecbound <- st_read("PB2002_boundaries.shp")
mat <- st_intersects(tecbound, st_as_sfc(st_bbox(s4df)))
tecbound <- tecbound[apply(mat, 1, any), ]
tecbound <- tecbound %>%
  mutate(NiceName = case_match(
    Name,
    "NB-SB" ~ "BSSL",
    "NB-MN" ~ "BSSL",
    "MN-SB" ~ "BSSL",
    "NB-SB" ~ "BSSL",
    .default = "Other"
  ))
```

```{r}
dist_BSSL <- tecbound %>%
  filter(NiceName == "BSSL") %>%
  st_union() %>%
  st_distance(s4df) %>%
  drop() %>%
  units::drop_units()
s4df <- s4df %>%
  mutate(dist = dist_BSSL)
```

### Strike of BSSL
The strike (up to $\pm \pi$) of the faults at the closest point to each earthquake.

First need to split the faults into segments
```{r}
tecbound_interest <- tecbound %>%
  filter(NiceName == "BSSL")
teccoords <- tecbound_interest %>%
  st_coordinates()
strike <- teccoords %>%
  as_tibble() %>%
  tibble::rowid_to_column() %>%
  st_as_sf(coords = c("X", "Y"), crs = st_crs(tecbound)) %>%
  lwgeom::st_geod_azimuth() %>%
  units::drop_units()
# make strike between 0 and 2pi
strike[which(strike < 0)] <- strike[which(strike < 0)] + 2*pi
# get segments as sf objects
segs <- cbind(teccoords[-nrow(teccoords), c("X", "Y")], teccoords[-1, c("X", "Y")]) %>%
  apply(1, function(vec){
    st_linestring(matrix(vec, 2, 2, byrow = TRUE))
  }, simplify = FALSE) %>%
  st_as_sfc(crs = st_crs(tecbound))
segs <- st_sf(strike = strike, fault = teccoords[-nrow(teccoords), "L1"], geometry = segs)
# remove the bearings corresponding to jumping between faults
segs <- segs[teccoords[-nrow(teccoords), "L1"] - teccoords[-1, "L1"] >= -0.5, ]

# L1 refers to the feature so can get back to plate names etc
segs$FaultName <- tecbound_interest$Name[segs$fault]
segs$NiceName <- tecbound_interest$NiceName[segs$fault]
```


```{r}
segs <- segs %>%
   mutate(strike = case_when(strike > pi ~ strike - pi,
                             TRUE ~ strike))
```

```{r}
#| fig.width: 8
#| fig.height: 2
segs %>%
  # mutate(strike = cut(strike, c(0,1.7,2.5, pi), include.lowest = TRUE)) %>%
  ggplot() +
  geom_sf(aes(col = strike), linewidth = 2) +
  scale_color_viridis_c() +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
```
Find closest segment to each earthquake and use that for strike.
```{r}
segidx <- st_nearest_feature(s4df, segs)
strike_BSSL <- segs$strike[segidx, drop = TRUE]
s4df <- bind_cols(s4df, fstrike = strike_BSSL)
```

Below plots the assigned fault's strike (`fstrike`) closest to each earthquake

```{r}
#| fig.width: 8
#| fig.height: 2
segs %>%
  ggplot() +
  geom_sf(aes(col = strike), linewidth = 2) +
  geom_point(data = s4df,
    aes(x = Longitude, y = Latitude, fill = fstrike), 
    shape = 21,
    show.legend = FALSE) +
  scale_color_viridis_c(name = "Strike", limits = range(segs$strike)) +
  scale_fill_viridis_c(name = "Strike", limits = range(segs$strike)) +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
```

Strike looks correct.

```{r}
#| fig.width: 8
#| fig.height: 2
ggplot() +
  geom_sf(data = world) +
  geom_point(data = s4df, aes(x = Longitude, y = Latitude, col = dist/1000)) +
  geom_sf(show.legend = FALSE, data = filter(tecbound, NiceName == "BSSL")) +
  theme_bw() +
  scale_color_viridis_c(name = "Distance (km)", transform = "log10") +
  theme(axis.title = element_blank()) +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
```


## Look for Outliers (SI Figure)
Here I'll look for outliers.
I'll view the moment tensors orthogonally projected onto axes determined by the first and second moment of the data such that
 the mean moment tensor has `Y1=1` and the covariance of the data in `Y2`...`Y5` coordinates is diagonal.
 The moment tensors according to these axes are obtained using `sphm:::standardise_sph()`.

Point colour is given by earthquake longitude.
Background colour is the average earthquake longitude for that part of projected $S^4$.
The identified outliers are labelled.

```{r}
#| fig.width: 12
#| fig.height: 13

outliers <- c(
  "182" = "general",
  "306" = "general",
  "76" = "general",
  "254" = "general",
  "169" = "general",
  "87" = "general",
  "175" = "longitude",
  "260" = "longitude"
)
outliers <- outliers %>%
  tibble::enframe(name = "Number", value = "outlier") %>%
  mutate(Number = as.integer(Number))

s4df %>%
  st_drop_geometry() %>%
  mutate(stdcoords = as_tibble(
    sphm:::standardise_sph(as.matrix(across(c(s1, s2, sMrt, sMrf, sMtf)))),
    .name_repair = "minimal")) %>%
  tidyr::unnest_wider(stdcoords, names_sep = "") %>%
  rename_with(~gsub("stdcoords", "Y", .)) %>%
  left_join(outliers, by = "Number") %>%
  pivot_coordpairs(coordnames = paste0("Y", 1:5)) %>%
  pairedplotggprep() +
  stat_summary_2d(fun = mean,
                    aes(z = Longitude, fill = after_stat(value)),
                  bins = 10) +
  scale_fill_viridis_c(name = "Longitude") +
  geom_point(aes(fill = Longitude), size = 2, shape = 21) +
  ggrepel::geom_label_repel(aes(label = Number,
                                col = as.factor(outlier)),
                            data = ~filter(.x, !is.na(outlier)),
                            label.padding = 0.1,
                            min.segment.length = 0,
                            box.padding = 1,
                            show.legend = FALSE) +
  scale_colour_manual(values = c("black", "grey"))
ggsave("earthq_mtensors_outlier.pdf", width = 12, height = 13)
```

From these plots we can see 6 earthquakes very different to the rest in at least some of the coordinates Y1 - Y5.
Earthquakes 182, 306, 76, 87 and 169 were outlying in Y1.
Earthquake 254 is an outlier in Y5.
Furthermore, earthquake 175 and to a lesser extent, earthquake 260, have high longitude, but have moment tensors close to low longitude earthquakes.


There also appears to be a shift in earthquake moment tensors with longitude < 148 (blue) vs other earthquakes (green-yellow), which we will incorporate into regression later.


## Remove Outliers
The outliers by region are:
```{r}
outliers <- outliers %>% #remove duplicates
  group_by(Number) %>%
  summarise(outlier = paste0(outlier, collapse = ","))

s4df %>%
  left_join(outliers, by = "Number") %>%
  filter(!is.na(outlier)) %>%
  st_drop_geometry() %>%
  select(Number, region, outlier) %>%
  arrange(region)
```


```{r}
s4df_clean <- s4df %>%
  left_join(outliers, by = "Number") %>%
  filter(is.na(outlier))
nrow(s4df_clean)
s4df_clean$Depth %>% as.factor() %>% summary()
```

## Main Figure: Earthquake Locations
```{r}
#| fig.width: 7
#| fig.height: 2
ggplot() +
  geom_sf(data = world) +
  geom_point(data = s4df %>% left_join(outliers, by = "Number") %>% filter(!is.na(outlier)),
             aes(x = Longitude, y = Latitude),
             shape = 4,
             position = position_jitter(width = 0.05, height = 0.05, seed = 1),
             show.legend = FALSE) +
  geom_point(data = s4df %>% left_join(outliers, by = "Number") %>% filter(is.na(outlier)),
             aes(x = Longitude, y = Latitude, col = Longitude),
             position = position_jitter(width = 0.05, height = 0.05, seed = 1),
             show.legend = FALSE) +
  scale_color_viridis_c() +
  # scale_shape_manual(values = c(4, 16)) +
  geom_sf(data = tecbound %>% filter(NiceName !="Other"), aes(lty = NiceName), show.legend = FALSE) +
  # geom_sf(data = regions %>% filter(region %in% 2:4), fill = NA, show.legend = FALSE) +
  scale_linetype_manual(values = c(NGT = "dashed", BSSL = "solid", Other = "dotted")) +
  theme_bw() +
  theme(axis.title = element_blank()) +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
ggsave("earthquakelocations.pdf", width = 7, height = 2)
```


Caption: Shallow earthquake locations near the Bismarck Sea Seismic Lineation (solid line).
Some jitter has been introduced because
`r s4df %>% select(Latitude, Longitude) %>% duplicated() %>% sum()` are colocated.

## Build covariates
Scale and center all Euclidean covariates to have mean 0 and sd of 1.

```{r}
xe <- s4df_clean %>%
  st_drop_geometry() %>%
  select(fstrike,
         Latitude,
         Longitude
         ) %>%
  mutate(Longitude.L148 = (Longitude > 148) * Longitude) %>%
  as.matrix()
xestd <- xe %>%
  scale() |>
  as_tibble()
cor(xestd)
```

# Default Start for SvMF Regression
```{r}
mod_SvMF <- mobius_SvMF(s4df_clean %>% 
                        select(s1, s2, sMrt, sMrf, sMtf) %>% 
                        st_drop_geometry() %>% 
                        as.matrix(),
                      xs = NULL, 
                      xe = xestd %>% as.matrix(),
                      type = "Shogo",
                      G01behaviour = "free")
mod_SvMF$k
mod_SvMF$AIC
mod_SvMF$a
mod_SvMF$DoF
```

# SI Figure: Random Starts
```{r}
restarts <- pbapply::pblapply(1:100, function(seed){
  # randomly generates a Kassel-form link
  start <- sphm:::rmnlink_cann(p = 5, qs = 0, qe = ncol(xestd) + 2, preseed = seed)
  # convert to Shogo form:
  set.seed(seed+1)
  Qe <- mclust::randomOrthogonalMatrix(ncol(xestd)+1, 5-1)
  bigQe <- cbind(0, rbind(0, Qe))
  bigQe[, 1] <- 0
  bigQe[1,1] <- 1
  start$Qe <- bigQe
  start$ce <- 1
  mobius_SvMF(s4df_clean %>% 
                          select(s1, s2, sMrt, sMrf, sMtf) %>% 
                          st_drop_geometry() %>% 
                          as.matrix(),
                      xs = NULL, 
                      xe = xestd %>% as.matrix(),
                      type = "Shogo",
                      G01behaviour = "free",
                      mean = start)
}, cl = 2)
badrestarts <- unlist(lapply(restarts, inherits, "try-error"))
restarts <- restarts[!badrestarts]
```

```{r}
lapply(restarts, "[[", "AIC") %>%
  unlist() %>%
  tibble::enframe("seed", "AIC") %>%
  ggplot()+
  geom_histogram(aes(x = AIC), bins = 30) +
  geom_vline(xintercept = mod_SvMF$AIC, col = "blue") +
  geom_rug(aes(x = AIC))

ggsave("earthq_restarts.pdf", width = 7, height = 5)
```

```{r}
idx <- which.min(lapply(restarts, "[[", "AIC") %>% unlist())
mod_SvMF <- restarts[[idx]]
```

# SI Table: Estimated Parameters
Below is the estimated concentration, the AIC and degrees of freedom of this regression.
```{r}
mod_SvMF$k
mod_SvMF$AIC
mod_SvMF$DoF
```

```{r, results='asis'}
library(kableExtra)
df <- data.frame(t(mod_SvMF$a))
colnames(df) <- 1:ncol(df)
mykbl <- df %>%
  mutate(across(everything(), ~formatC(.x, digits = 2, format = "f"))) %>%
  kbl(booktabs = TRUE, position = "!h", escape = FALSE, format = "latex") %>%
  add_header_above(c("Scales" = ncol(df)), escape = FALSE)
kableExtra::save_kable(mykbl,
                       "earthq_a.pdf", 
                       keep_tex = TRUE)
mykbl
```

```{r, results='asis'}
library(kableExtra)
df <- data.frame(mod_SvMF$G0)
label_map <- c(
  s1 = "(Mrr - Mtt)/$\\sqrt{2}$",
  s2 = "(Mrr + Mtt - 2Mff)/$\\sqrt{6}$",
  sMrf = "Mrf /$\\sqrt{2}$",
  sMrt = "Mrt /$\\sqrt{2}$",
  sMtf = "Mtf /$\\sqrt{2}$"
)
row.names(df) <- label_map[row.names(df)]
colnames(df) <- c("$\\gamma_{01}$", "$\\gamma_{02}$", "$\\gamma_{03}$", "$\\gamma_{04}$", "$\\gamma_{05}$")
mykbl <- df %>%
  mutate(across(everything(), ~formatC(.x, digits = 2, format = "f"))) %>%
  kbl(booktabs = TRUE, position = "!h", escape = FALSE, format = "latex")
kableExtra::save_kable(mykbl,
                       "earthq_G0.pdf", 
                       keep_tex = TRUE)
mykbl
```

```{r}
cann <- sphm:::as_mnlink_cann(mod_SvMF$mean)
```

```{r, results='asis'}
df <- data.frame(cann$Be)
colnames(df) <- paste0("col", 1:ncol(df))
mykbl <- df %>%
  mutate(across(everything(), ~round(.x,2))) %>%
  mutate(across(everything(), as.character)) %>%
  kbl(booktabs = TRUE, position = "!h", escape = FALSE, format = "latex",
      row.names = NA,
      col.names = NULL) %>%
  add_header_above(c("$B_e$" = ncol(df)), escape = FALSE)
kableExtra::save_kable(mykbl,
                       "earthq_Be.pdf", 
                       keep_tex = TRUE)
mykbl
```

In the software, there is a dummy zero-valued covariate that is used to allow for the option of a denominator below $B_e Q_e^\top$.

```{r, results='asis'}
df <- data.frame(cann$Qe[-1,-1])
colnames(df) <- paste0("col", 1:ncol(df))
rownames(df)[1] <- "Strike"
mykbl <- df %>%
  mutate(across(everything(), ~round(.x, 2))) %>%
  mutate(across(everything(), as.character)) %>%
  kbl(booktabs = TRUE, position = "!h", escape = FALSE, format = "latex",
      row.names = TRUE,
      col.names = NULL) %>%
  add_header_above(c(" " = 1, "$R_e$" = ncol(df)), escape = FALSE)
kableExtra::save_kable(mykbl,
                       "earthq_Re.pdf", 
                       keep_tex = TRUE)
mykbl
```

```{r, results='asis'}
label_map <- c(
  s1 = "(Mrr - Mtt)/$\\sqrt{2}$",
  s2 = "(Mrr + Mtt - 2Mff)/$\\sqrt{6}$",
  sMrf = "Mrf /$\\sqrt{2}$",
  sMrt = "Mrt /$\\sqrt{2}$",
  sMtf = "Mtf /$\\sqrt{2}$"
)
df <- data.frame(cann$P)
row.names(df) <- label_map[row.names(df)]
mykbl <- df %>%
  mutate(across(everything(), ~round(.x, 2))) %>%
  mutate(across(everything(), as.character)) %>%
  kbl(booktabs = TRUE, position = "!h", escape = FALSE, format = "latex",
      col.names = NULL) %>%
  add_header_above(c(" "=1, "$B_0$" = ncol(df)), escape = FALSE)
kableExtra::save_kable(mykbl,
                       "earthq_B0.pdf", 
                       keep_tex = TRUE)
mykbl
```

# SI Figure: Predictions
```{r}
get_predobspairsdf_nat <- function(mod,
                               extra = NULL,
                               colpairs = combn(c("s1", "s2", "sMrf", "sMrt", "sMtf"), 2, simplify = FALSE)){
  # apply to p1 too
  p1pairs <- tibble::as_tibble_row(mod$mean$p1) %>%
    pivot_coordpairs(colpairs = colpairs)
  
  # apply to G0 too
  # first get start and end location of pretty axes around G01
  arrowends <- t(t(mod$G0[,-1] - mod$G0[,1]) * mod$a[-1]/10) + mod$G0[,1] # convert to difference, scale difference by scales a, add start back
  colnames(arrowends) <- paste0("G0", 1+ (1:ncol(arrowends)))
  
  axisarrows <- lapply(1:nrow(mod$pred), function(idx){
    pred <- mod$pred[idx, ]
    # rotate (parallel transport) arrows to be around predicted mean
    arrowends <- sphm:::rotationmat_amaral(mod$G0[,1], pred) %*% arrowends
    # include start location too
    names(pred) <- paste0("start", rownames(arrowends))
    as_tibble(t(arrowends), rownames = "Axis") %>%
      bind_cols(t(pred)) %>%
      bind_cols(extra[idx, ])
  }) %>%
    bind_rows()
  # apply orthogonal projections
  axisarrows_pairs <- lapply(colpairs, function(pair) {
    axisarrows %>%
      select(everything(), -starts_with("s"), -starts_with("starts"), all_of(pair), all_of(paste0("start", pair))) %>%
      rename(A = last_col(3), B = last_col(2), startA = last_col(1), startB = last_col(0)) %>%
      mutate(pair1=pair[1],
             pair2=pair[2],
             pair = paste(pair, collapse = "-"))
  }) %>%
    bind_rows()
  
  # old G0 axes
  colnames(mod$G0) <- paste0("G0", 1:ncol(mod$G0))
  G0pairs <- as_tibble(t(mod$G0), rownames = "Axis") %>%
    pivot_coordpairs(colpairs = colpairs)
  
  predsobs <- bind_cols(mod$pred %>%
                          as_tibble() %>%
                          rename_with(~paste0("p_", .)),
                        mod$y,
                        extra)
  pair_dfs <- lapply(colpairs, function(pair) {
    predsobs %>%
      select(everything(), -starts_with("s"), -starts_with("p_s"), all_of(pair),all_of(paste0("p_", pair))) %>%
      rename(A = last_col(3), B = last_col(2), p_A = last_col(1), p_B = last_col(0)) %>%
      mutate(pair1=pair[1],
             pair2=pair[2],
             pair = paste(pair, collapse = "-"))
  })
  pairsdf <- bind_rows(pair_dfs)
  attr(pairsdf, "p1") <- p1pairs
  attr(pairsdf, "G0") <- G0pairs
  attr(pairsdf, "Garrows") <- axisarrows_pairs
  attr(pairsdf, "coordnames") <- c("s1", "s2", "sMrt", "sMrf", "sMtf")
  pairsdf
}
```

```{r}
#| fig.width: 12
#| fig.height: 13
get_predobspairsdf_nat(mod_SvMF, s4df_clean %>% select(-starts_with("s"))) %>%
  pairedplotggprep() +
  geom_segment(aes(x=p_A, y=p_B, xend=A, yend=B, col = Longitude),
               alpha = 0.5,
                arrow = grid::arrow(length = unit(0.02, "npc"))) +
  geom_point(aes(x=p_A, y=p_B, fill = Longitude),
             size = 1.5,
             shape = 21) +
  geom_point(aes(x=A, y=B), size = 2, col = "blue",
             shape = 4,
             data = attr(get_predobspairsdf_nat(mod_SvMF), "p1")) +
  scale_fill_viridis_c() +
  scale_color_viridis_c() +
  ggtitle("Predictions")
ggsave("earthq_predictions.pdf", width = 12, height = 13)
```

# Main Figure: Observed and Predicted
```{r}
obsplots <- get_predobspairsdf_nat(mod_SvMF, s4df_clean %>% select(-starts_with("s")),
                     colpairs = strsplit(c("s1-s2", "sMtf-s2", "sMrt-s2"), "-")) %>%
    pairedplotggprep() +
    geom_point(aes(x=A, y=B, col = Longitude), size = 1) +
    scale_color_viridis_c() +
    theme(plot.margin = unit(c(0,2,0,2), "mm"),
        axis.line.y = element_line(arrow = grid::arrow(type = "closed", angle = 10, length = unit(10, "points")),
                                 linewidth = 0.2),
          strip.text = element_text(margin = margin(0, 0, 0, 0), size = 8),
          strip.text.x.bottom = element_blank(),
        legend.position = "right")

paireddf <- get_predobspairsdf_nat(mod_SvMF, s4df_clean %>% select(-starts_with("s")),
                     colpairs = strsplit(c("s1-s2", "sMtf-s2", "sMrt-s2"), "-"))
predplots <- paireddf %>%
  pairedplotggprep() +
  geom_segment(aes(x=p_A, y=p_B, xend=A, yend=B, col = Longitude),
               alpha = 1,
                arrow = grid::arrow(length = unit(0.02, "npc"))) +
  geom_point(aes(x=p_A, y=p_B, fill = Longitude),
             size = 1.5,
             shape = 21) +
  geom_point(aes(x=A, y=B), size = 2, col = "blue",
             shape = 21,
             data = ~attr(paireddf, "G0") %>% filter(Axis == "G01") %>% filter(pair %in% .x$pair)) +
  geom_point(aes(x=A, y=B), size = 2, col = "blue",
             shape = 4,
             data = ~(attr(paireddf, "p1") %>% filter(pair %in% .x$pair))
             ) +
  scale_color_viridis_c() +
  scale_fill_viridis_c() +
  theme(plot.margin = unit(c(0,2,0,2), "mm"),
        axis.line = element_line(arrow = grid::arrow(type = "closed", angle = 10, length = unit(10, "points")),
                                 linewidth = 0.2),
          strip.text = element_text(margin = margin(0, 0, 0, 0), size = 8),
        legend.position = "right")

obsplots/
  predplots + 
  plot_layout(guides = "collect")
ggsave("earthquake_results.pdf", width = 7, height = 4)
```

# Angles to $b_{01}$ and $\gamma_{01}$
The range of the angle between predicted mean and estimated $b_{01}$ is:
```{r}
range(acos(mod_SvMF$pred %*% mod_SvMF$mean$p1))
```

The range of the angle between predicted mean and estimated $\gamma_{01}$ is:
```{r}
range(acos(mod_SvMF$pred %*% mod_SvMF$G0[,1]))
```

# Predictions in Standardised Coordinates
```{r}
get_predobspairsdf <- function(mod,
                               extra = NULL,
                               colpairs = combn(paste0("Y",1:5), 2, simplify = FALSE),
                               useG0 = FALSE){
  # standard rotations
  if (useG0){
    ystd <- standardise_sph(mod$y, tG = t(mod$G0))
  } else {
    ystd <- standardise_sph(mod$y)
  }
  
  colnames(ystd) <- paste0("Y", 1:ncol(ystd))
  predstd <- standardise_sph(mod$pred, attr(ystd, "std_rotation"))
  colnames(predstd) <- paste0("p_Y", 1:ncol(predstd))
  # apply to p1 too
  p1std <- standardise_sph(matrix(mod$mean$p1, nrow = 1), attr(ystd, "std_rotation"))
  colnames(p1std) <- paste0("Y", 1:ncol(ystd))
  p1pairs <- as_tibble(p1std) %>%
    pivot_coordpairs(colpairs = colpairs)
  # apply to G0 too
  # first get start and end location of pretty axes around G01
  arrowends <- t(t(mod$G0[,-1] - mod$G0[,1]) * mod$a[-1]/10) + mod$G0[,1] # convert to difference, scale difference by scales a, add start back
  colnames(arrowends) <- paste0("G0", 1+ (1:ncol(arrowends)))
  
  axisarrows <- lapply(1:nrow(mod$pred), function(idx){
    pred <- mod$pred[idx, ]
    # rotate (parallel transport) arrows to be around predicted mean, then rotate again for standardised coordinates
    stdarrowends <- attr(ystd, "std_rotation") %*% sphm:::rotationmat_amaral(mod$G0[,1], pred) %*% arrowends
    rownames(stdarrowends) <- paste0("Y", 1:ncol(ystd))
    # include start location too
    stdpred <- drop(attr(ystd, "std_rotation") %*% pred)
    names(stdpred) <- paste0("start", rownames(stdarrowends))
    as_tibble(t(stdarrowends), rownames = "Axis") %>%
      bind_cols(t(stdpred)) %>%
      bind_cols(extra[idx, ])
  }) %>%
    bind_rows()
  # apply orthogonal projections
  axisarrows_pairs <- lapply(colpairs, function(pair) {
    axisarrows %>%
      select(everything(), -starts_with("Y"), -starts_with("startY"), all_of(pair), all_of(paste0("start", pair))) %>%
      rename(A = last_col(3), B = last_col(2), startA = last_col(1), startB = last_col(0)) %>%
      mutate(pair1=pair[1],
             pair2=pair[2],
             pair = paste(pair, collapse = "-"))
  }) %>%
    bind_rows()

  # old G0 axes
  G0std <- attr(ystd, "std_rotation") %*% mod$G0
  rownames(G0std) <- paste0("Y", 1:ncol(ystd))
  colnames(G0std) <- paste0("G0", 1:ncol(G0std))
  G0pairs <- as_tibble(t(G0std), rownames = "Axis") %>%
    pivot_coordpairs(colpairs = colpairs)
  
  predsobs <- bind_cols(predstd,
                        ystd,
                        extra)
  pair_dfs <- lapply(colpairs, function(pair) {
    predsobs %>%
      select(everything(), -starts_with("Y"), -starts_with("p_Y"), all_of(pair),all_of(paste0("p_", pair))) %>%
      rename(A = last_col(3), B = last_col(2), p_A = last_col(1), p_B = last_col(0)) %>%
      mutate(pair1=pair[1],
             pair2=pair[2],
             pair = paste(pair, collapse = "-"))
  })
  pairsdf <- bind_rows(pair_dfs)
  attr(pairsdf, "p1") <- p1pairs
  attr(pairsdf, "G0") <- G0pairs
  attr(pairsdf, "Garrows") <- axisarrows_pairs
  attr(pairsdf, "coordnames") <- paste0("Y",1:5)
  pairsdf
}
```

```{r}
getG0arrows <- function(mod_SvMF){
  names(mod_SvMF$a) <- paste0("G0", 1:length(mod_SvMF$a))
  tibble::enframe(mod_SvMF$a, name = "Axis", value = "scale")
  orientations <- get_predobspairsdf(mod_SvMF) %>%
    attr("G0") %>%
    left_join(tibble::enframe(mod_SvMF$a, name = "Axis", value = "scale"), by = "Axis") %>%
    # mutate(across(c(A, B, starts_with("Y")), ~case_when(Axis != "G01" ~ .x * scale/20, TRUE ~ .x))) #scale axes by their estimated scale, except G01
    group_by(pair) %>%
    arrange(Axis) %>%
    select(-starts_with("Y")) %>%
    mutate(
      Astart = first(A),
      Bstart = first(B),
      A = A - Astart,
      B = B - Bstart) %>% #make everything vectors - works because projection orthogonal
      # across(c(A, B), ~.x - first(.x))) %>% #make everything vectors - works because projection orthogonal
    mutate(across(c(A, B), ~.x * scale/10)) %>% #scale axes by their estimated scale (G01 is 0 currently so scaling it does nothing)
    filter(Axis != "G01") %>%
    ungroup() %>%
    # add G01 back into A B etc
    mutate(A = A + Astart, B = B + Bstart)
  return(orientations)
}
```

```{r}
#| fig.width: 15
#| fig.height: 13
defaultplot_pred <- function(mod_SvMF, s4df_clean, focusaxes = FALSE, focusresponse = FALSE){
  plotobj <- get_predobspairsdf(mod_SvMF, bind_cols(s4df_clean, rdist = mod_SvMF$dists, rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x)))) %>%
    pairedplotggprep() 
  if (!focusaxes){
    plotobj <- plotobj %>%
      addaxes(mod_SvMF, axiscolour = rep("grey", 4), alpha = 0.5)
  }
  if (focusresponse){
    plotobj <- plotobj +
      geom_point(aes(x=A, y=B, col = Longitude), size = 2)
  } else {
    plotobj <- plotobj +
      geom_point(aes(x=p_A, y=p_B, col = Longitude), size = 2)
  }
  plotobj <- plotobj +
    geom_point(aes(x=A, y=B), size = 2, col = "blue",
               data = attr(get_predobspairsdf(mod_SvMF), "p1")) +
    geom_point(aes(x=-A, y=-B), size = 2, col = "blue", shape = 21,
               data = attr(get_predobspairsdf(mod_SvMF), "p1")) +
    geom_point(aes(x=A, y=B), size = 2, col = "red",
               data = attr(get_predobspairsdf(mod_SvMF), "G0") %>% filter(Axis == "G01")) +
    geom_segment(aes(x=Astart,y=Bstart, xend=A, yend=B),
                 data = getG0arrows(mod_SvMF) %>% filter(Axis == "G02"),
                 arrow = grid::arrow(length = unit(0.02, "npc"))) +
    geom_segment(aes(x=Astart,y=Bstart, xend=A, yend=B),
                 col = "grey",
                 data = getG0arrows(mod_SvMF) %>% filter(Axis == "G03"),
                 arrow = grid::arrow(length = unit(0.02, "npc"))) +
    geom_point(aes(x=-A, y=-B), size = 2, col = "red", shape = 21,
               data = attr(get_predobspairsdf(mod_SvMF), "G0") %>% filter(Axis == "G01")) +
    geom_segment(aes(x=p_A, y=p_B, xend=A, yend=B, col = Longitude),
                 alpha = 0.5,
                  arrow = grid::arrow(length = unit(0.02, "npc"))) +
    scale_color_viridis_c() +
    ggtitle("Prediction Highlighted")
  if (focusaxes){
    plotobj <- plotobj %>%
      addaxes(mod_SvMF, axiscolour = c("red", "green", "blue", "purple")) 
  }
  return(plotobj)
}
addaxes <- function(plotobj, mod_SvMF, axiscolour = c("red", "green", "blue", "purple"), alpha = 1){
  plotobj +
    geom_segment(aes(x=startA,y=startB, xend=A, yend=B),
                 data = attr(get_predobspairsdf(mod_SvMF), "Garrows") %>% filter(Axis == "G02"),
                 alpha = alpha,
                 col = axiscolour[1]) +
                 # arrow = grid::arrow(length = unit(0.02, "npc"), type = "closed")) +
    geom_segment(aes(x=startA,y=startB, xend=A, yend=B),
                 data = attr(get_predobspairsdf(mod_SvMF), "Garrows") %>% filter(Axis == "G03"),
                 alpha = alpha,
                 col = axiscolour[2]) +
                 # arrow = grid::arrow(length = unit(0.02, "npc"), type = "closed")) +
    geom_segment(aes(x=startA,y=startB, xend=A, yend=B),
                 data = attr(get_predobspairsdf(mod_SvMF), "Garrows") %>% filter(Axis == "G04"),
                 alpha = alpha,
                 col = axiscolour[3]) +
                 # arrow = grid::arrow(length = unit(0.02, "npc"), type = "closed")) +
    geom_segment(aes(x=startA,y=startB, xend=A, yend=B),
                 data = attr(get_predobspairsdf(mod_SvMF), "Garrows") %>% filter(Axis == "G05"),
                 alpha = alpha,
                 col = axiscolour[4])
                 # arrow = grid::arrow(length = unit(0.02, "npc"), type = "closed")) 
}
defaultplot_pred(mod_SvMF, s4df_clean)
defaultplot_pred(mod_SvMF, s4df_clean, focusaxes = TRUE)
```

# Model Diagnostics
## Rotated Residuals (SI Figure)
Here we plot the rotated residuals against each of the axes defined by $\Gamma_0$. We can see the ellipsiodal nature of Scaled von Mises Fisher residuals. The maximum size of a rotated residual is $1$ (grey circular boundary).

```{r}
#| fig.width: 8
#| fig.height: 7
mod_SvMF$rresids_G0 %>%
  as_tibble() %>%
  bind_cols(s4df_clean, rdist = mod_SvMF$dists) %>%
  bind_cols(rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x))) %>%
  pivot_coordpairs(coordnames = paste0("r", 1:4)) %>%
  pairedplotggprep() +
  stat_summary_2d(fun = mean, 
                  aes(z = Longitude, fill = after_stat(value)),
                  bins = 10) +
  geom_point(aes(fill = Longitude), size = 2, shape = 21) +
  scale_fill_viridis_c(name = "Longitude") +
  scale_color_viridis_c(name = "Longitude")

ggsave("earthq_rresids.pdf", width = 8, height = 7)
```


## Residual Mean by Covariates (SI Figure)
```{r}
bind_cols(mod_SvMF$rresids_G0, s4df_clean) %>%
  st_drop_geometry() %>%
  tidyr::pivot_longer(matches("^r.$"), names_to = "raxis", values_to = "value") %>%
  tidyr::pivot_longer(c(Latitude, Longitude, fstrike, dist, Depth), names_to = "covariate", values_to = "cvalue") %>%
  filter(!(covariate == "dist" & (cvalue > 50000))) %>%
  ggplot(aes(x = cvalue, y = value)) +
  facet_grid(rows = vars(raxis), cols = vars(covariate), scales = "free",
             labeller = as_labeller(c(Depth = "Depth", dist = "Distance", fstrike = "Strike", Longitude = "Longitude", Latitude = "Latitude",
                                      r1 ="r1",r2="r2",r3="r3",r4="r4"))) +
  geom_hline(yintercept = 0, col = "blue", lty = "dashed") +
  geom_smooth(method = "loess", formula = 'y ~ x', data = ~filter(.x, covariate != "Depth")) +
  geom_point() +
  stat_summary(fun.data = mean_se, geom = "errorbar", width = 1.5, col = "blue", data = ~filter(.x, covariate == "Depth")) +
  scale_y_continuous(name = "Residual") +
  scale_x_continuous(name = "Covariate Value")
ggsave("earthq_rresids2.pdf", width = 8, height = 6)
```

Above is the residuals in each of the basis coordinates given by the SvMF orientation against covariate values.

## Standardised Residuals
Below the same residuals are transformed using the estimated concentration and Scale von Mises Fisher scales so that, at high-concentrations, the residuals should be close to a standard multivariate Normal (Scealy and Wood, 2019, Proposition 2).

```{r}
#| fig.width: 6
#| fig.height: 5
mod_SvMF$rresids_std %>%
  as_tibble() %>%
  bind_cols(s4df_clean, rdist = mod_SvMF$dists) %>%
  pivot_coordpairs(coordnames = paste0("r", 1:4)) %>%
  ggplot(mapping = aes(x=A, y=B, col = fstrike)) + 
  facet_wrap(vars(pair2, pair1)) +
  theme(strip.text.y = element_text(angle = 90),
        strip.placement = "outside",
        axis.title = element_blank(),
        strip.background = element_blank()) +
  geom_hline(yintercept = 0, lty = "dashed") +
  geom_vline(xintercept = 0, lty = "dashed") +
  geom_point(size = 1) +
  scale_color_viridis_c() +
  coord_fixed()
```

## Standardised Residual Distance (SI Figure)
```{r}
#| fig.width: 5
#| fig.height: 2
stdrdist <- sqrt(rowSums(mod_SvMF$rresids_std^2))
stdrdist[!attr(mod_SvMF$rresids_std, "samehemisphere")] <- NA_real_
p1 <- bind_cols(srdist = stdrdist, rdist = mod_SvMF$dists, s4df_clean) %>%
  bind_cols(rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x))) %>%
  ggplot(aes(y=srdist, x = Longitude)) +
  geom_point() +
  ylab("Scaled Residual\nDistance")

p2 <- bind_cols(srdist = stdrdist, rdist = mod_SvMF$dists, s4df_clean) %>%
  bind_cols(rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x))) %>%
  ggplot(aes(y=srdist, x = fstrike)) +
  geom_point() +
  ylab("Scaled Residual\nDistance") +
  xlab("Strike")

p1 + p2 + plot_layout(axes = "collect")
ggsave("earthq_srdist.pdf", width = 5, height = 2)
```

## Residual Distance (Unstandardised)
```{r}
#| fig.width: 5
#| fig.height: 2
p1 <- bind_cols(rdist = mod_SvMF$dists, s4df_clean) %>%
  bind_cols(rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x))) %>%
  ggplot(aes(y=rdist, x = Longitude)) +
  geom_point()

p2 <- bind_cols(rdist = mod_SvMF$dists, s4df_clean) %>%
  bind_cols(rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x))) %>%
  ggplot(aes(y=rdist, x = fstrike)) +
  geom_point()

p1 + p2
```

# Likelihood Ratio Test of vMF vs SvMF

First get best vMF model
```{r}
mod_vMF <- mobius_vMF(y = mod_SvMF$y,
                     xs = NULL, 
                     xe = mod_SvMF$xe,
                     type = "Shogo")
mod_vMF_restarts <- pbapply::pblapply(1:100, function(seed){sphm:::mobius_vFM_restart(mod_vMF, seed)})
lapply(mod_vMF_restarts, "[[", "AIC") %>%
  unlist() %>%
  tibble::enframe("seed", "AIC") %>%
  ggplot()+
  geom_freqpoly(aes(x = AIC), bins = 30) +
  geom_vline(xintercept = mod_vMF$AIC, col = "blue") +
  geom_rug(aes(x = AIC))
idx <- which.min(lapply(mod_vMF_restarts, "[[", "AIC") %>% unlist())
mod_vMF <- mod_vMF_restarts[[idx]]  
mod_vMF$k
mod_vMF$AIC
```

```{r}
getlikR <- function(y){
  mod1 <- mobius_vMF(y,
                     xs = NULL, 
                     xe = mod_vMF$xe,
                     type = "Shogo",
                     start = mod_vMF$est)
  mod2 <- withCallingHandlers({mobius_SvMF(y,
                      xs = NULL, 
                      xe = mod_vMF$xe,
                      type = "Shogo",
                      G01behaviour = "free",
                      mean = mod_SvMF$mean,
                      k = mod_SvMF$k,
                      a = mod_SvMF$a,
                      G0 = mod_SvMF$G0)},
        warning = function(w){
        if (grepl("p!=3", conditionMessage(w))) {
          invokeRestart("muffleWarning")
        }
      })
  if ((mod1$nlopt$status != 4) || (mod2$nlopt$status != 4)){
    return(list(likR = NA_real_,
         vMF = mod1,
         SvMF = mod2))
  }
  lLik1 <- sphm:::dS2S_constV(mod1$y, xs = NULL, xe =mod1$xe,
              mean = mod1$est,
              k = mod1$k,
              a = rep(1, 5),
              G0 = mod2$G0) %>%
    colSums()
  lLik2 <- sphm:::dS2S_constV(mod2$y, xs = NULL, xe =mod2$xe,
              mean = mod2$mean,
              k = mod2$k,
              a = mod2$a,
              G0 = mod2$G0) %>%
    colSums()

  list(likR = -2* (lLik1[["R"]] - lLik2[["R"]]),
       vMF = mod1,
       SvMF = mod2)
}
null_likRs <- pbapply::pblapply(1:1000, function(seed){
  set.seed(seed)
  y_ld <- sphm:::rS2S_constV(xs = NULL, 
                   xe = mod_vMF$xe,
                   mnparam = mod_vMF$mean,
                   k = mod_vMF$k,
                   a = rep(1, 5),
                   G0 = diag(1,5))
  sum(y_ld[,6])
  y <- y_ld[,-6]
  getlikR(y)
})
obs <- getlikR(s4df_clean %>% 
                        select(s1, s2, sMrt, sMrf, sMtf) %>% 
                        st_drop_geometry() %>% 
                        as.matrix())
```

```{r}
null_likRs_vec <- lapply(null_likRs, "[[", "likR") %>% unlist()
sum(is.na(null_likRs_vec))
sum(!is.na(null_likRs_vec))
```

There were a few cases where the regression did not converge, and these have been discarded.
P-value is the probability, under the null, of getting a likelihood-ratio that is at least as large as the observed ratio:
```{r}
mean(null_likRs_vec > obs$likR, na.rm = TRUE)
```
This small $p$-value suggests that the data was not drawn from a vMF regression.

# Parametric Bootstrap Regions for `a`
Lets look at the CI for the scales of the SvMF.

```{r}
Bests <- pbapply::pblapply(1:1000, function(seed){
  set.seed(seed)
  y <- sphm:::rS2S_constV(xs = NULL, 
                   xe = mod_SvMF$xe,
                   mnparam = mod_SvMF$mean,
                   k = mod_SvMF$k,
                   a = mod_SvMF$a,
                   G0 = mod_SvMF$G0)[,-6]
  newmod <- withCallingHandlers({mobius_SvMF(y,
                      xs = NULL, 
                      xe = mod_SvMF$xe,
                      type = "Shogo",
                      G01behaviour = "free",
                      mean = mod_SvMF$mean,
                      k = mod_SvMF$k,
                      a = mod_SvMF$a,
                      G0 = mod_SvMF$G0)},
          warning = function(w){
        if (grepl("p!=3", conditionMessage(w))) {
          invokeRestart("muffleWarning")
        }
      })
  return(newmod[c("mean", "k", "a", "G0")])
}, cl = 2)
```


```{r}
Bests_a <- lapply(Bests, "[[", "a") %>%
  simplify2array() %>%
  t()
colnames(Bests_a) <- paste0("a", 1:5)
summary(Bests_a)
```

## 95% CI for a (SI Table)
```{r, results='asis'}
df <- rbind(mod_SvMF$a[-1],
            apply(Bests_a[,-1], 2, quantile, probs = c(0.025, 0.975)) %>%
  round(2)) %>%
  as.data.frame()
row.names(df) <- c("Estimate","Lower", "Upper")
mykbl <- df %>%
  mutate(across(everything(), ~formatC(.x, digits = 2, format = "f"))) %>%
  kbl(booktabs = TRUE, position = "!h", escape = FALSE, format = "latex",
      col.names = paste0("a",2:5)) %>%
  add_header_above(c(" "=1, "Scales" = 4), escape = FALSE)
kableExtra::save_kable(mykbl,
                       "earthq_aCI.pdf", 
                       keep_tex = TRUE)
mykbl
```
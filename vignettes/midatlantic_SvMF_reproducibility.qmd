---
title: "Mid-Atlantic Regression"
author: "Kassel Hingee"
format:
  pdf:
    toc: true
    number-sections: true
    header-includes: |
      \usepackage{hyperref}
      \hypersetup{
        pdfpagemode=UseOutlines, % open bookmarks panel
        bookmarksopen=true,      % unfold top-level bookmarks
        bookmarksopenlevel=10,   % unfold all levels
        bookmarksnumbered=true   % number bookmarks
      }
---

---

__Code version: `r packageVersion("sphm")`__

```{r prep}
#| include: false
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(R.matlab)
library(ggplot2)
library(sphm)
library("R.matlab")
library(tibble)
library(dplyr)
```

```{r Residual Plotting Function}
#| include: false
viridis_switch <- function(continuous) {
  if (continuous) {
    return(scale_color_viridis_c)
  } else {
    return(scale_color_viridis_d)
  }
}

soloplt <- function(rresids, covars, extraaes = list(NULL), continuous = TRUE, basemapping = aes(x = r1, y = r2)){
  colorfun <- viridis_switch(continuous = continuous)
  bind_cols(rresids, covars) %>%
    ggplot(modifyList(basemapping, extraaes)) +
    geom_point() +
    colorfun() +
    # scale_y_continuous(transform = scales::transform_pseudo_log(sigma = pi/32, base = exp(1))) +
    # scale_x_continuous(transform = scales::transform_pseudo_log(sigma = pi/32, base = exp(1))) +
    geom_vline(xintercept = 0, lty = "dotted", col = "blue") +
    geom_hline(yintercept = 0, lty = "dotted", col = "blue") +
    coord_equal()
}
# soloplt(small_Shogo$rresid, sphdf, aes(col = Depth), continuous = TRUE)
```

```{r Tools for ggally with circle}
#| include: false
# Create data for the unit circle
theta <- seq(0, 2 * pi, length.out = 100)
circle_df <- data.frame(x = cos(theta), y = sin(theta))

custom_ggally_points <- function(data, mapping, ...) {
  ggplot(data, mapping) +
    geom_point(...) +
    geom_path(data = circle_df, aes(x = x, y = y), inherit.aes = FALSE, color = "grey") +
    coord_fixed()
}
```

# Data

```{r data}
#| include: false
raw <- readMat("midatlantic.mat")
rownames(raw$X) <- paste0("Y", 1:3)
rownames(raw$Y) <- paste0("X", 1:3) #X3 runs from north pole towards south pole
fulldf <- bind_cols(t(raw$X), t(raw$Y)) %>%
  mutate(westedge = Y2 < -0.3)
```

# Euc Covariates
```{r}
xe <- fulldf %>% 
  select(westedge)
xestd <- xe %>% scale() %>% as_tibble()
```

# Our SvMF Model
```{r ours}
#| include: false
ymean <- colMeans(fulldf %>% select(starts_with("Y")) %>% as.matrix())
ymean <- ymean/sqrt(sum(ymean^2))
mod <- mobius_SvMF(y = fulldf %>% select(starts_with("Y")) %>% as.matrix(),
       xs = fulldf %>% select(starts_with("X")) %>% as.matrix(),
       xe = xestd %>% as.matrix(),
       G01behaviour = "free",
       fix_qs1 = FALSE, type = "Shogo")
mod[c("k", "DoF", "AIC")]
mod$a
```

# Pretty Data Plot
```{r}
ymean <- colMeans(fulldf %>% select(starts_with("Y")))
ymean <- ymean/sqrt(sum(ymean^2))
#project to equator
ymeanproj <- c(ymean[1:2], 0)
ymeanproj/sphm:::vnorm(ymeanproj)
target <- c(1,0,0)
prettyrot <- sphm:::rotationmat_amaral(ymeanproj, target)
prettyY <- (fulldf %>%
  select(Y1, Y2, Y3) %>%
  as.matrix()) %*% t(prettyrot)
colnames(prettyY) <- paste0("Y", 1:3)
prettyX <- (fulldf %>%
  select(X1, X2, X3) %>%
  as.matrix()) %*% t(prettyrot)
colnames(prettyX) <- paste0("X", 1:3)
prettyXmean <- colMeans(prettyX)
prettyXmean <- prettyXmean/sphm:::vnorm(prettyXmean)
# denomloc <- drop(prettyrot %*% sphm:::as_mnlink_cann(mod$mean)$Qs[,1])
plotdata <- bind_cols(prettyY, prettyX, westedge = fulldf$westedge) %>%
  as_tibble() %>%
  ggplot() +
  geom_segment(aes(x=X2, y=X3, xend=Y2, yend=Y3), lty = "dashed", col = "grey") +
  geom_point(aes(x=Y2, y=Y3), shape = 4) +
  geom_point(aes(x=X2, y=X3, fill = westedge), show.legend = FALSE, shape = 21) +
  geom_path(data = circle_df, aes(x = x, y = y), inherit.aes = FALSE, color = "grey") +
  scale_fill_manual(values = c("black", "white")) +
  theme_void() +
  coord_fixed() 
  # mark mean of spherical covariate (obtained earlier)
  # annotate("point", x = prettyXmean[2], y = prettyXmean[3], shape = 24, size = 2)
  # annotate("point", x = denomloc[2], y = denomloc[3], shape = 3, size = 4, col = "blue")
plotdata
```

```{r Paine Plot Resids and Dists}
#| include: false
calc_Paine_resids <- function(mod){
  mod$rresids <- rotatedresid(t(mod$Z), t(mod$predmean), base = sphm:::nthpole(3))[,-1]
  mod$dists <- acos(rowSums(t(mod$Z) * t(mod$predmean)))
  colnames(mod$rresids) <- c("r1", "r2")
  return(mod)
}

predplot_ESAG <- function(esagmod){
  nthproj <- (diag(3) - sphm:::nthpole(3) %*% t(sphm:::nthpole(3)))
  obspred <- bind_cols(obs = as_tibble(t(nthproj %*% prettyrot %*% esagmod$Qmat %*% esagmod$Z)[,-1]),
                       pred = as_tibble(t(nthproj %*% prettyrot %*% esagmod$Qmat %*% esagmod$predmean)[,-1]) %>% rename_with(.fn = ~ paste0("p", .x)),
                       .name_repair = "unique")
  obspred %>%
    as_tibble() %>%
    ggplot() +
    geom_segment(aes(x = pV1, y = pV2, xend = V1, yend = V2),
                 arrow = grid::arrow(length = unit(0.01, "npc"))) +
    geom_path(data = circle_df, aes(x = x, y = y), inherit.aes = FALSE, color = "grey") +
    coord_fixed() +
    theme_void()
}
```

# Predictions
The below 'ours' model is using Shogo's link with an extra covariate for an intercept and G01 free.
The results here are from a local optimisation using gradient from default starting values.
I've checked that global search for the best vMF regression does not find anything better.

```{r}
cann <- sphm:::as_mnlink_cann(mod$mean)
cann
```

Lets try to interpret the fitted link.

```{r}
cann$Bs %*% t(cann$Qs[,-1])
cann$Be %*% t(cann$Qe[,-1])
```

The first direction away from $B_{01}$ (first row in above) is roughly equally influenced by X1, X2 and X3 (all are about 0.5) with west edge having very little influence (given the values of standardised westedge).
The second direction away from $B_{01}$ (second row in above) is roughly equally influenced by X1 and X2 but much less by X3 (which is the N-S direction) and westedge plays a role.

```{r}
cann$Qs[,1]
```

Some general scaling occurs with greater influence from X3 (N-S direction), then X2 then X1.

## Table of Estimates
```{r Estimates Table, results='asis'}
library(kableExtra)
df <- cbind("diag($B_s$)" = diag(cann$Bs),
      "diag($B_e$)" = diag(cann$Be),
      tQe = t(cann$Qe[-1,-1])) %>%
  as.data.frame()
row.names(df) <- c("$t_2$", "$t_3$")
mykbl <- kbl(df, booktabs = TRUE, position = "!h", escape = FALSE, format = "latex", digits = 2) %>%
  add_header_above(c(" "=3, "$R_e^\\top$" = 2), escape = FALSE)
kableExtra::save_kable(mykbl,
                       "estimatestable.pdf", 
                         keep_tex = TRUE)
mykbl
```


## Plot

```{r Projected Predictions Plot}
#| include: false
predplot <- function(svmfresult){
  ystd <- standardise_sph(svmfresult$y, tG = prettyrot)
  projmat <- (diag(3) - sphm:::nthpole(3) %*% t(sphm:::nthpole(3)))
  obs <- ystd %*% projmat[,-1]
  pred <- svmfresult$pred %*% t(attr(ystd, "std_rotation")) %*% projmat[,-1]

  obspred <- bind_cols(obs = as.data.frame(obs),
            pred = as.data.frame(pred) %>% rename_with(.fn = ~ paste0("p", .x)),
            cov = as.data.frame(prettyX) %>% rename_with(.fn = ~ paste0("p", .x)),
            .name_repair = "unique")

  outplot <- obspred %>%
    as_tibble() %>%
    cbind(fulldf) %>%
    mutate(angle = acos(svmfresult$pred %*% svmfresult$G0[,1])) %>%
    ggplot() +
    # geom_point(aes(x=pX2, y=pX3), shape = 3) +
    # geom_segment(aes(x=pX2, y=pX3, xend=pV1, yend=pV2), data = , lty = "dashed", col = "grey") +
    geom_segment(aes(x = pV1, y = pV2, xend = V1, yend = V2),
                 arrow = grid::arrow(length = unit(0.01, "npc"))) +
    geom_path(data = circle_df, aes(x = x, y = y), inherit.aes = FALSE, color = "grey") +
    coord_fixed() +
    theme_void()

  # mark predictions for mean xs
  nth <- attr(ystd, "std_rotation") %*% c(0,0,1)
  #the below relies on the specific order of xe
  xetrans <- attributes(scale(xe))[c("scaled:center", "scaled:scale")]
  xe_nat <- c(westedge = 0)
  xe_nat <- rbind(xe_nat, xe_nat)
  xe_nat[2, "westedge"] <- 1
  xe_std <- scale(xe_nat, center = xetrans$`scaled:center`, scale = xetrans$`scaled:scale`) %>%
    cbind(dummyzero = 0, ones = 1)
  tmpxe <- xe_std[,names(svmfresult$mean$qe1)]
  xs <- colMeans(svmfresult$xs)
  xs <- xs/sphm:::vnorm(xs)
  eastwestedge <- mnlink(xs = rbind(xs, xs),
         xe = tmpxe,
         param = svmfresult$mean) %*% t(attr(ystd, "std_rotation"))
  outplot <- outplot +
    annotate("point", x = eastwestedge[1, 2], y = eastwestedge[1, 3], fill = "black", shape = 24, size = 2) +
    annotate("point", x = eastwestedge[2, 2], y = eastwestedge[2, 3], fill = "white", shape = 24, size = 2)
  
  # mark prediction when xs = rs1
  # rs1 <- sphm:::as_mnlink_cann(svmfresult$mean)$Qs[,1]
  # eastwestedge_rs1 <- mnlink(xs = rbind(rs1, rs1),
  #        xe = tmpxe,
  #        param = svmfresult$mean) %*% t(attr(ystd, "std_rotation"))
  # outplot <- outplot +
  #   annotate("point", x = eastwestedge_rs1[1, 2], y = eastwestedge_rs1[1, 3], fill = "black", shape = 24, size = 4) +
  #   annotate("point", x = eastwestedge_rs1[2, 2], y = eastwestedge_rs1[2, 3], fill = "white", shape = 24, size = 4)
  
  # mark columns of Qs on the plot
  prettyQs <- attr(ystd, "std_rotation") %*% sphm:::as_mnlink_cann(svmfresult$mean)$Qs
  outplot <- outplot +
    annotate("point", x = prettyQs[2,1], y = prettyQs[3,1], shape = 3, size = 2, col = switch(1+(prettyQs[1,1] > 0), "grey", "black")) +
    annotate("point", x = prettyQs[2,2], y = prettyQs[3,2], shape = 4, size = 2, col = switch(1+(prettyQs[1,2] > 0), "grey", "black")) +
    annotate("point", x = prettyQs[2,3], y = prettyQs[3,3], shape = 8, size = 2, col = switch(1+(prettyQs[1,3] > 0), "grey", "black"))
  
if (!is.null(svmfresult$G0)){
  G0proj <- (diag(3) - sphm:::nthpole(3) %*% t(sphm:::nthpole(3))) %*% attr(ystd, "std_rotation") %*% svmfresult$G0
  mnaxes_proj <- (diag(3) - sphm:::nthpole(3) %*% t(sphm:::nthpole(3))) %*% attr(ystd, "std_rotation") %*% sphm:::as_mnlink_cann(svmfresult$mean)$P
  eps = 0.2
  outplot <- outplot + 
  annotate("segment", x = G0proj[2,1], y = G0proj[3,1],
           xend = G0proj[2,1] + eps*G0proj[2,2], 
           yend = G0proj[3,1] + eps*G0proj[3,2], col = "grey",
           lty = "solid") +
  annotate("segment", x = G0proj[2,1], y = G0proj[3,1],
           xend = G0proj[2,1] + eps*G0proj[2,3], 
           yend = G0proj[3,1] + eps*G0proj[3,3], col = "grey",
           lty = "31") +
  
  annotate("segment", x = mnaxes_proj[2,1], y = mnaxes_proj[3,1],
           xend = mnaxes_proj[2,1] + eps*mnaxes_proj[2,2], 
           yend = mnaxes_proj[3,1] + eps*mnaxes_proj[3,2], col = "black",
           lty = "solid") +
  annotate("segment", x = mnaxes_proj[2,1], y = mnaxes_proj[3,1],
           xend = mnaxes_proj[2,1] + eps*mnaxes_proj[2,3], 
           yend = mnaxes_proj[3,1] + eps*mnaxes_proj[3,3], col = "black",
           lty = "31") 
}
return(outplot)
}
plotours <- predplot(mod)
plotours
```



```{r iag1}
#| include: false
IAG1 <- R.matlab::readMat("../../sphere_reg_code/reverse_westedge/SEuc2S_IAG1.mat")
IAG1$Lik <- -IAG1$fval.IAG1
IAG1$DoF <- (3*nrow(IAG1$Cov) + 1 + 1)
IAG1$AIC <- 2*IAG1$DoF - 2 * (IAG1$Lik)
IAG1$AIC
IAG1$predmean <- IAG1$predmean1
IAG1 <- calc_Paine_resids(IAG1)
plotIAG1 <- predplot_ESAG(IAG1)
plotIAG1
```

```{r esag1}
#| include: false
ESAG1 <- R.matlab::readMat("../../sphere_reg_code/reverse_westedge/SEuc2S_ESAG1.mat")
ESAG1$Lik <- 251.7973
ESAG1$predmean <- ESAG1$predmean1
ESAG1 <- calc_Paine_resids(ESAG1)
ESAG1$DoF <- (4*nrow(ESAG1$Cov) + 1 + 1)
ESAG1$AIC <- 2*ESAG1$DoF - 2 * (ESAG1$Lik)
ESAG1$AIC
plotESAG1 <- predplot_ESAG(ESAG1)
plotESAG1
```

```{r esag2}
#| include: false
ESAG2 <- R.matlab::readMat("../../sphere_reg_code/reverse_westedge/SEuc2S_ESAG2.mat")
ESAG2$Lik <- 243.1426
ESAG2$DoF <- 5 * nrow(ESAG2$X.SEuc) + #maps for mu and gamma
  0 #rotation matrix Q 6 if estimated, 0 otherwise
ESAG2$AIC <- 2*ESAG2$DoF - 2 * (ESAG2$Lik)
ESAG2$AIC
ESAG2$Qmat <- IAG1$Yrot
ESAG2$Z <- ESAG2$Ystd
ESAG2$predmean <- ESAG2$mean.SEuc2S.esag
plotESAG2 <- predplot_ESAG(ESAG2)
plotESAG2
```

Note that we have not optimised Q for ESAG2 because optimisation did not converge. Instead Q was the default ...?

```{r}
#| fig.width: 10
#| fig.height: 10
#| echo: false
library(patchwork)
plotours + ggtitle("Ours") + theme(legend.position = "none") +
plotIAG1 + ggtitle("IAG1") + 
  plotESAG1 + ggtitle("ESAG1") + 
  plotESAG2 + ggtitle("ESAG2")
```

# LOOCV MSE
```{r}
loocvmseSvMF <- function(mod){
  stopifnot(inherits(mod$mean, "mnlink_Omega"))
  dists <- pbapply::pblapply(1:nrow(mod$y), function(idx){
    newmod <- mobius_SvMF(mod$y[-idx,],
                xs = mod$xs[-idx,],
                xe = mod$xe[-idx,c(-1,-ncol(mod$xe)), drop = FALSE],
                fix_qs1 = FALSE,
                type = "Shogo",
                G01behaviour = "free",
                mean = mod$mean,
                k = mod$k,
                a = mod$a,
                G0 = mod$G0)
    pred <- mnlink(xs = mod$xs[idx,, drop = FALSE],
                   xe = mod$xe[idx,, drop = FALSE],
                   param = newmod$mean)
    obs <- mod$y[idx,]
    Euc <- sphm:::vnorm(drop(obs - pred))
    angle <- acos(rowSums(obs * pred))
    return(c(
      Euc = Euc,
      angle = angle
    ))
  })
  dists <- dists %>%
    simplify2array() %>%
    t() %>%
    as_tibble()
  dists %>%
    summarise(across(everything(), ~sum(.x^2)/nrow(mod$y)))
}
loocvmseSvMF(mod)
```

Both of these are smaller than the LOOCV MSE that Rosenthal's PLT acheived of `r 7.4E-2`, which corresponds to the Euc metric MSE.

# Residual Size
Geodesic distance between predicted mean and observation
```{r}
#| echo: false
#| messages: false
multidists <- bind_cols(ours = mod$dists,
          # IAG1 = IAG1$dists,
          ESAG1 = ESAG1$dists)
maxdist <- max(multidists)
maxlim <- (floor(maxdist * 100) + 1)/100
d1plot <- multidists %>%
  tibble::rowid_to_column() %>%
  tidyr::pivot_longer(-rowid, names_to = "Model", values_to = "Distance") %>%
  ggplot(aes(x = Distance, col = Model)) +
  geom_freqpoly(aes(lty = Model), 
                bins = 20,
                breaks = seq(0, maxlim, by = 0.01)) +
  coord_cartesian(xlim = c(0, maxlim), expand = FALSE) +
  scale_x_continuous(name = "Geodesic Distance") +
  theme_minimal() + 
  theme(legend.position = "bottom",
        axis.title.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.x = element_blank())

d2plot <- multidists %>%
  tibble::rowid_to_column() %>%
  tidyr::pivot_longer(-rowid, names_to = "Model", values_to = "Distance") %>%
  ggplot(aes(x = Distance, y = Model, col = Model)) +
  # geom_violin() +
  ggbeeswarm::geom_quasirandom(aes(shape = Model), orientation = "y") +
  scale_shape_manual(values = c(3,4)) +
  scale_x_continuous(name = "Geodesic Distance") +
  coord_cartesian(xlim = c(0, maxlim), expand = FALSE, clip = "off") +
  theme_minimal() + 
  theme(legend.position = "none",
        axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.x = element_blank())

d1plot/d2plot + plot_layout(axes = "collect", guides = "collect")
```

# DoF
```{r}
#| echo: false
c(Ours = mod$DoF, IAG1 = IAG1$DoF, ESAG1 = ESAG1$DoF, ESAG2 = ESAG2$DoF)
```

Our mean link with free rs1 has `r sphm:::mobius_DoF(p=dim(mod$mean)["p"],qs=dim(mod$mean)["qs"],qe=dim(mod$mean)["qe"], fix_qe1 = TRUE)` degrees of freedom.

# AIC
```{r}
#| echo: false
c(Ours = mod$AIC, IAG1 = IAG1$AIC, ESAG1 = ESAG1$AIC, ESAG2 = ESAG2$AIC)
```

# Main Figure
```{r}
#| fig.width: 12
#| fig.height: 3.5
(plotdata + ggtitle("(a) data") + theme(plot.title = element_text(hjust = 0.5))) +
(plotours + theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + ggtitle("(b) ours")) +
  (plotESAG1 + ggtitle("(c) structure 1") + theme(plot.title = element_text(hjust = 0.5))) +
  (plotESAG2 + ggtitle("(d) structure 2") + theme(plot.title = element_text(hjust = 0.5))) +
  plot_layout(ncol = 4, widths = c(3,3,3,3))
ggsave("midatlantic_fig.pdf", width = 12, height = 3.5)
```

Caption: Regression for the midatlantic ridge data.
From left: midatlanic ridge (circles) and corresponding locations on the continent (crosses) from Rosenthal el at (2014);
our regression; Paine et al structure 1 regression;
Paine et al structure 2 regression.
The sphere is shown orthogonally projected with north pointing up the page.
Arrows: start at the predicted mean and end at the observed continental location, and thus represent residuals.
Filled symbols: eastern side.
Unfilled symbols: western side.
Triangles: Mean of ridge locations and corresponding predicted mean for western or eastern side.
Plus symbol: estimated value of $r_{s1}$.
Pair of black lines: direction of the estimated second (solid) and third (dashed) columns of $B_0$ located at the estimated first column $b_{01}$ of $B_0$.
Pair of grey lines: estimated directions of $\gamma_{02}$ (solid) and $\gamma_{03}$ (dashed) located at the estimated $\gamma_{01}$.




# Appendix

## Hessian of Likelihood at Optimum
The parameter vector is longer than the DoF because of the constraints in the optimisation.
There should be DoF + `(3-1) * (3 - 2) / 2` positive eigenvalues.
The term `(3-1) * (3 - 2) / 2` if for the commutativity constraint on Omega, which the likelihood computation does not account for, so appears as extra degrees of freedom in its Hessian.

```{r}
#| echo: false
(eigen(mod$nlopt$solution_Hes_f, symmetric = TRUE, only.values = TRUE)$values |>
  split(1:ncol(mod$nlopt$solution_Hes_f) > mod$DoF + (3-1) * (3 - 2) / 2))[[1]]
```

These are all positive and non-zero, which confirms that the optimisation routine has found a local maximum of the likelihood.

## Check Other Starts for vMF
```{r}
#| cache: true
restarts <- pbapply::pblapply(1:100, function(seed){
  start <- sphm:::rmnlink_cann(p = 3, qs = 3, qe = ncol(xe) + 2, preseed = seed)
  # convert to Shogo form:
  set.seed(seed+1)
  Qe <- mclust::randomOrthogonalMatrix(ncol(xe)+1, 3-1)
  bigQe <- cbind(0, rbind(0, Qe))
  bigQe[, 1] <- 0
  bigQe[1,1] <- 1
  start$Qe <- bigQe
  start$ce <- 1
  modvMF <- mobius_vMF(y = fulldf %>% select(starts_with("Y")) %>% as.matrix(),
      xs = fulldf %>% select(starts_with("X")) %>% as.matrix(),
      xe = xe %>% as.matrix(),
      fix_qs1 = FALSE, type = "Shogo",
      start = start)
}, cl = 2)
lapply(restarts, "[[", "obj") %>%
  unlist() %>%
  enframe("seed", "objective") %>%
  ggplot()+
  geom_freqpoly(aes(x = objective), bins = 30) +
  geom_vline(xintercept = mod$preest$nlopt$objective, col = "blue") +
  geom_rug(aes(x = objective))
```

Estimation is somewhat stable. That is good.
Would be better if it was even more stable though!!!

## Check Other Starts for SvMF
```{r}
restarts <- pbapply::pblapply(1:100, function(seed){
  # randomly generates a Kassel-form link
  start <- sphm:::rmnlink_cann(p = 3, qs = 3, qe = ncol(xestd) + 2, preseed = seed)
  # convert to Shogo form:
  set.seed(seed+1)
  Qe <- mclust::randomOrthogonalMatrix(ncol(xestd)+1, 5-1)
  bigQe <- cbind(0, rbind(0, Qe))
  bigQe[, 1] <- 0
  bigQe[1,1] <- 1
  start$Qe <- bigQe
  start$ce <- 1
  mobius_SvMF(y = fulldf %>% select(starts_with("Y")) %>% as.matrix(),
              xs = fulldf %>% select(starts_with("X")) %>% as.matrix(), 
              xe = xestd %>% as.matrix(),
              type = "Shogo",
              G01behaviour = "free",
              mean = start)
}, cl = 2)
badrestarts <- unlist(lapply(restarts, inherits, "try-error"))
restarts <- restarts[!badrestarts]
lapply(restarts, "[[", "AIC") %>%
  unlist() %>%
  tibble::enframe("seed", "AIC") %>%
  ggplot()+
  geom_freqpoly(aes(x = AIC), bins = 30) +
  geom_vline(xintercept = mod$AIC, col = "blue") +
  geom_rug(aes(x = AIC))
```

## Check Restart of SvMF
```{r}
mod2 <- sphm:::mobius_SvMF(y = fulldf %>% select(starts_with("Y")) %>% as.matrix(),
       xs = fulldf %>% select(starts_with("X")) %>% as.matrix(),
       xe = xestd %>% as.matrix(),
       G01behaviour = "free",
       mean = mod$mean,
       a = mod$a,
       k = mod$k,
       G0 = mod$G0,
       G0reference = mod$G0,
       fix_qs1 = FALSE, type = "Shogo", doprelim = FALSE)
```




## Plans for Tables and Plots in Paper

 1. 5-panneled figure of midatlantic data and the predictions from the 4 models above.
Additional marks on our prediction to aid interpretation:
    1. westedge = 0/1 when xs = Rs1
    1. arrows away from these points in directions given by axes of B0
    1. Arrows indicating east, west, north, south.
 1. Table of likelihood, AIC and median geodesic residual distance
 
 
 In Appendix:
 
 1. Table of estimated loadings for our fitted model

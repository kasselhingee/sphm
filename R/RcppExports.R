# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' The unnormalised log-likelihood of a SvMF Sphere-Sphere Regression with Mobius Mean Link and Variance Axes Aligned with P.
#' @description Three functions in a format compatible with `tapefun`. A difficulty is that the P matrix needs and SVD to get out of the Omega parameterisation so two functions for alternating between optimising the mean (with `kappa` and `a` fixed, and `G` aligned to a fixed `P`) and optimising a, with the mean fixed and concentration fixed, and updating `P` inbetween.
#' @param vec For `_alignedG_mean`: A parameter vector specifying the mean via the Omega vectorisation.
#' @param dyn For `_alignedG_mean`: A p+1+p*p length vector of kappa, then a1, a2, ..., then P as a vector of stacked columns.
#' @param p_in The dimension p
#' @param yx The observations and covariates cbind together as row vectors
ull_S2S_alignedG_mean <- function(vec, dyn, p_in, yx) {
    .Call(`_sphm_ull_S2S_alignedG_mean`, vec, dyn, p_in, yx)
}

#' @param vec For `_alignedG_a`: A p-2 vector of log(a3), log(a4), log(a5), ... log(a2) will be calculated as the negative sum of the others to satisfy the prod=1 constraint on a2,...
#' @param dyn For `_alignedG_a`: A vector of kappa then a1
#' @param pOmegavec For `_alignedG_a`: A vector of p then the Omega vectorisation, then `as.vector(P)`. Due to an SVD to extract P from Omega vec, taping the dependence on Omega would be unreliable. Furthermore R's SVD routine seems more reliable than Eigen's.
ull_S2S_alignedG_a <- function(vec, dyn, pOmegavecP, yx) {
    .Call(`_sphm_ull_S2S_alignedG_a`, vec, dyn, pOmegavecP, yx)
}

#' @param k For `_alignedG_k`: A parameter vector specifying the concentration k
#' @param dyn For `_alignedG_k`: A p*q + p + p*p length vector of Omegavec, then a1, a2, ..., then P as a vector of stacked columns.
#' The P and Omega are provided seperately because of the non-smooth nature of SVD.
ull_S2S_alignedG_k <- function(k, dyn, p_in, yx) {
    .Call(`_sphm_ull_S2S_alignedG_k`, k, dyn, p_in, yx)
}

#' @describeIn ull_S2S_alignedG_mean Aligns the columns of the Mobius-link rotation matrix `P` for the mean to the columns of G. Note that the first column of the returned G is the given mean. Returns the matrix G.
alignedGcpp <- function(m, P) {
    .Call(`_sphm_alignedGcpp`, m, P)
}

cayleyTransform <- function(A) {
    .Call(`_sphm_cayleyTransform`, A)
}

inverseCayleyTransform <- function(M) {
    .Call(`_sphm_inverseCayleyTransform`, M)
}

vectorizeLowerTriangle <- function(A) {
    .Call(`_sphm_vectorizeLowerTriangle`, A)
}

inverseVectorizeLowerTriangle <- function(vec) {
    .Call(`_sphm_inverseVectorizeLowerTriangle`, vec)
}

S2S_constV_nota1_tovecparams <- function(omvec, k, aremaining, Kstar) {
    .Call(`_sphm_S2S_constV_nota1_tovecparams`, omvec, k, aremaining, Kstar)
}

ull_S2S_constV_forR <- function(y, x, omvec, k, a1, aremaining, Kstar) {
    .Call(`_sphm_ull_S2S_constV_forR`, y, x, omvec, k, a1, aremaining, Kstar)
}

tape_ull_S2S_constV_nota1 <- function(omvec, k, a1, aremaining, Kstar, p_in, yx) {
    .Call(`_sphm_tape_ull_S2S_constV_nota1`, omvec, k, a1, aremaining, Kstar, p_in, yx)
}

meanlinkS2Scpp <- function(x, vec, p) {
    .Call(`_sphm_meanlinkS2Scpp`, x, vec, p)
}

#' Preliminary Objective in the style of the `generalfunction` class:
#' @param yx is the response and covariates *cbind* together. Each row an observation.
#' @param dyn is a zero length vector
#' @param p is required to separate yx and omvec. It is passed as a double for compatiblility witn generalfunction, so will have to be rounded to a integer within the function
#' @param dyn ignored
pobjS2Scpp <- function(omvec, dyn, p_in, yx) {
    .Call(`_sphm_pobjS2Scpp`, omvec, dyn, p_in, yx)
}

OmegaS2S_constraints <- function(vec, p) {
    .Call(`_sphm_OmegaS2S_constraints`, vec, p)
}

#' Function for taping a general function. The function must have signature
#' `veca1 fun(const veca1 & independent, const veca2 & dynamic, const vecd & constvec, const matd & constmat)`.
#' Differentiation of `fun` will occur with respect to the independent arguments. The taping will keep of dependence on the dynamic arguments so that the value of the dynamic arguments can be changed in the tape. The constants (constvec and constmat) will be baked into the tape (to change these constants `tapefun` will have to be called again.
#' 
#' If some of the arguments are unwanted, I'm hoping I can write the function so that vectors of length zero are okay.
#'
#' @param fun A function with the correct signature.
#' @param ind_t The value of the independent argument to use for taping.
#' @param dyn_t The value of the dynamic argument to use for taping.
#' @param constants The value of the constants argument.
#' @param check_for_nan Should the tape watch for nan values when in use? This can be useful to let the tape pass nan back to R
NULL

#' Tape using a function name in function_map 
#' @param func_name Name of function to tape. Name must be in the internal `function_map` object.
tape_namedfun <- function(func_name, ind_t, dyn_t, constvec, constmat, check_for_nan) {
    .Call(`_sphm_tape_namedfun`, func_name, ind_t, dyn_t, constvec, constmat, check_for_nan)
}

uldSvMF_cann <- function(y, k, a, G) {
    .Call(`_sphm_uldSvMF_cann`, y, k, a, G)
}

uldSvMF_muV <- function(y, k, m, a1, V) {
    .Call(`_sphm_uldSvMF_muV`, y, k, m, a1, V)
}

#' @param Vvec Vectorised form of matrix V ala vech
#' @param yk vector of y values, then the k. Will be dynamic parameters because the 'y' may be residuals and be updated frequently
#' @param a1m The tuning parameter a1 and the mean, which will often be the northpole
ull_SvMF_V <- function(Vvec, yk, a1m) {
    .Call(`_sphm_ull_SvMF_V`, Vvec, yk, a1m)
}


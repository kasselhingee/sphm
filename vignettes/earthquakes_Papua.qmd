---
title: "Regions 1-4 Shallow Mobius Regression"
author: "Kassel Hingee"
format:
  pdf:
    toc: true
    number-sections: true
    fig-width: 6.5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE)
library(ggplot2)
library(dplyr)
library(GGally)
library(patchwork)
library(sphm)
packageVersion("sphm")
```

# Raw Data
This data is copied directly from Hejrani et al (2017) Table 1.

```{r}
raw=read.table(file="./papua20240709.csv",
               header=T,sep=",", numerals = "warn.loss",
               colClasses = c(Origin.Time = "character"))
head(raw) %>%
  mutate(Origin.Time = paste0(substr(`Origin.Time`, 1, 6),"..")) %>%
  rename(Lon = Longitude,
         Lat = Latitude) %>%
  knitr::kable() %>%
  kableExtra::kable_styling(font_size = 8)
```

In this raw data:

+ `Origin.Time`. Hejrani references the GCMT project for origin times. Though not explicitly in Hejrani et al (2017), it seems this column is the format that GCMT uses for modern earthquakes, which is XYYYYMMDDhhmmZ where X is the type of data used, Z is for distinguishing events at the same time (day?) and the stuff in between ti time.
+ `Number` relates uniquely to increasing origin time.
+ `Lon` and `Lat` are the Longitude and Latitude of the earthquake
+ `Depth` is the depth (in kilometres) of the earthquake
+ `M**` are scaled elements of the earthquake moment tensors where `r`, `t`, `f` represent basis directions.
+ `Mw * 10^Exp` is a magnitude.
+ `Dcper` is related to how close the earthquake is a to a pure double-couple.

For later lets record the names of the `M**` columns in the same order as the symmetric-matrix vectorisation function `vech`:

```{r}
elementnames <- c("Mrr", "Mrt", "Mrf",
                  "Mtt", "Mtf",
                  "Mff")
```

# Transform to $S^4$
## Enforce Trace=0 and Scale=1
The moment tensors have traces that nearly 0.

```{r}
traces <- rowSums(raw[, c("Mrr", "Mtt", "Mff")])
traces %>%
  tibble::enframe(value = "trace") %>%
  ggplot() +
  geom_histogram(aes(x = trace)) +
  geom_rug(aes(x = trace))
```

Here I'll make the trace exactly zero.

```{r}
stddf <- raw %>%
  mutate(Mff = -Mrr - Mtt)
```

Now we scale the moment tensors to have a Frobenius norm of 1. The function `gettr2()` below is fast way to compute the square of the Frobenius norm without winding the 6 `M**` columns up into individual 3 x 3 matrices.
```{r tr2}
gettr2 <- function(ms){
  I2 <- ms[, 1] * ms[, 4] + ms[, 4] * ms[, 6] + ms[,1] * ms[,6] -
    ms[, 2]^2 - ms[, 5]^2 - ms[,3]^2
  I1 <- ms[, 1] + ms[, 4] + ms[, 6] #trace
  tr2 <- I1^2 - 2*I2
  return(tr2)
}
Fnorm <- sqrt(gettr2(stddf[, elementnames]))
stddf <- stddf %>%
  mutate(Fnorm = Fnorm) %>%
  mutate(across(starts_with("M"), ~.x/Fnorm))
```

Lets verify the result of these transformations on the first earthquake.

```{r}
elementvalues <- unlist(stddf[1, elementnames])
tmpM <- matrix(NA, 3, 3)
tmpM[lower.tri(tmpM, diag = TRUE)] <- elementvalues
tmpM[upper.tri(tmpM)] <- t(tmpM)[upper.tri(tmpM)]
colnames(tmpM) <- rownames(tmpM) <- c("r", "t", "f")

elementvalues
tmpM
sqrt(sum(tmpM^2))
sum(diag(tmpM))
```

The trace and norm are exactly 0 and 1 as desired.

## Moment Tensors as Unit Vectors in $R^5$
The diagonal elements must sum to zero, which puts them on a plane through the origin.
I'll use the Helmert submatrix to express these diagonal elements with respect to an orthonormal basis on this plane. The plane is two dimensions, so I'll call these new coordinates `s1` and `s2`.

```{r}
H <- rbind(c(1,-1, 0), c(1,1,-2))
H <- H/sqrt(rowSums(H^2))
diagproj <- t(H %*% t(stddf[, c("Mrr", "Mtt", "Mff")]))
colnames(diagproj) <- c("s1", "s2")
```

I'll scale the off diagonal elements by $\sqrt{2}$ because off-diagonal elements are counted twice in the Frobenius norm.

```{r}
offdiag <- stddf %>%
  mutate(sMrt = sqrt(2) * Mrt,
         sMrf = sqrt(2) * Mrf,
         sMtf = sqrt(2) * Mtf) %>%
  select(sMrt, sMrf, sMtf)
```

Combined these are unit vectors in $R^5$
```{r}
sqrt(rowSums(cbind(diagproj, offdiag)^2))
```

Lets combine back into full data frame
```{r}
s4df <- bind_cols(diagproj, offdiag, raw)
```

# Hejrani et al (2017)'s Regions
Here I have captured the regions from Fig 16 of Hejrani et al (2017) by visual assessment.
```{r}
library(sf)
ptmatrix <- function(xmin, xmax, ymin, ymax){
  matrix(c(xmin, ymax,   
           xmax, ymax,
           xmax, ymin,
           xmin, ymin,
           xmin, ymax), byrow = TRUE, ncol = 2)
}

regions <- st_sfc(st_polygon(list(ptmatrix(141, 144, -4, -2))),
                  st_polygon(list(ptmatrix(144, 147.3, -4, -2))),
                  st_polygon(list(ptmatrix(147.3, 150.3, -4, -2.5))),
                  st_polygon(list(ptmatrix(150.3, 152.5, -4.1, -3))),
                  st_polygon(list(ptmatrix(146.1, 151.5, -7.1, -5.7))),
                  st_polygon(list(ptmatrix(151.5, 153.5, -6.8, -4.7))),
                  st_polygon(list(ptmatrix(153.5, 156.7, -8.5, -5))),
                  st_polygon(list(ptmatrix(156.7, 159, -10, -8))),
       crs = 4326)
regions <- st_sf(region = factor(1:8, ordered = TRUE), geom = regions)
```

# Keep Only Shallow Eartquakes in Regions 2-4
Convert data into an `sf` object. Assuming that the longitude and latitude are using the GPS coordinate system.

```{r}
s4df <- sf::st_as_sf(s4df, coords = c("Longitude", "Latitude"), remove = FALSE)
sf::st_crs(s4df) <- 4326
s4df <- st_intersection(s4df, regions) 
s4df <- mutate(s4df, region = as.factor(region))
s4df <- s4df %>% 
  filter(region %in% 2:4) %>%
  filter(Depth <= 20)
nrow(s4df)
```

# Fig of earthquake locations, NGT and BSSL
Plate information was obtained from github `https://github.com/fraxen/tectonicplates`.

```{r}
#| eval: false
tmp <- paste0("https://github.com/fraxen/tectonicplates/raw/refs/heads/master/PB2002_boundaries.", c("dbf", "prj", "sbn", "sbx", "shp", "shp.xml", "shx")) |>
  lapply(function(x){download.file(x, basename(x))})
```

```{r}
library(sf)
tecbound <- st_read("PB2002_boundaries.shp")
mat <- st_intersects(tecbound, st_as_sfc(st_bbox(s4df)))
tecbound <- tecbound[apply(mat, 1, any), ]
tecbound <- tecbound %>%
  mutate(NiceName = case_match(
    Name,
    "NB-SB" ~ "BSSL",
    "NB-MN" ~ "BSSL",
    "MN-SB" ~ "BSSL",
    "NB-SB" ~ "BSSL",
    .default = "Other"
  ))

centroids <- tecbound %>%
  st_crop(xmin = 141.0, xmax = 153, ymin = -4.5, ymax = -2) %>%
  # filter(NiceName != "Other") %>%
  group_by(NiceName, Name) %>%
  summarize() %>%
  mutate(centroid = st_centroid(geometry)) %>%
  mutate(cenX = st_coordinates(centroid)[, "X"],
         cenY = st_coordinates(centroid)[, "Y"])
```


```{r}
library("rnaturalearth")
world <- ne_countries(scale = "medium", returnclass = "sf")
```

Now I will plot the earthquakes we use in this analysis.

```{r}
#| fig.width: 7
#| fig.height: 2
ggplot() +
  geom_sf(data = world) +
  geom_point(data = s4df, aes(x = Longitude, y = Latitude), position = position_jitter(width = 0.05, height = 0.05, seed = 1)) +
  geom_sf(data = tecbound %>% filter(NiceName !="Other"), aes(lty = NiceName), show.legend = FALSE) +
  geom_sf(data = regions %>% filter(region %in% 2:4), fill = NA, show.legend = FALSE) +
  scale_linetype_manual(values = c(NGT = "dashed", BSSL = "solid", Other = "dotted")) +
  theme_bw() +
  theme(axis.title = element_blank()) +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
```

Caption: Shallow earthquake locations near the Bismarck Sea Seismic Lineation (solid line).
Some jitter has been introduced because
`r s4df %>% select(Latitude, Longitude) %>% duplicated() %>% sum()` are colocated.

# Fault distance and strike
For each earthquake we find the distance to the BSSL and also the strike (up to $\pm \pi$) of the fault at this closest point.
For BSSL, the fault plane is vertical so strike may as well be below $\pi$.

## Distance to BSSL
```{r}
dist_BSSL <- tecbound %>%
  filter(NiceName == "BSSL") %>%
  st_union() %>%
  st_distance(s4df) %>%
  drop() %>%
  units::drop_units()
s4df <- s4df %>%
  mutate(dist = dist_BSSL)
```

## Strike of BSSL
The strike (up to $\pm \pi$) of the faults at the closest point to each earthquake.

First need to split the faults into segments
```{r}
tecbound_interest <- tecbound %>%
  filter(NiceName == "BSSL")
teccoords <- tecbound_interest %>%
  st_coordinates()
strike <- teccoords %>%
  as_tibble() %>%
  tibble::rowid_to_column() %>%
  st_as_sf(coords = c("X", "Y"), crs = st_crs(tecbound)) %>%
  lwgeom::st_geod_azimuth() %>%
  units::drop_units()
# make strike between 0 and 2pi
strike[which(strike < 0)] <- strike[which(strike < 0)] + 2*pi
# get segments as sf objects
segs <- cbind(teccoords[-nrow(teccoords), c("X", "Y")], teccoords[-1, c("X", "Y")]) %>%
  apply(1, function(vec){
    st_linestring(matrix(vec, 2, 2, byrow = TRUE))
  }, simplify = FALSE) %>%
  st_as_sfc(crs = st_crs(tecbound))
segs <- st_sf(strike = strike, fault = teccoords[-nrow(teccoords), "L1"], geometry = segs)
# remove the bearings corresponding to jumping between faults
segs <- segs[teccoords[-nrow(teccoords), "L1"] - teccoords[-1, "L1"] >= -0.5, ]

# L1 refers to the feature so can get back to plate names etc
segs$FaultName <- tecbound_interest$Name[segs$fault]
segs$NiceName <- tecbound_interest$NiceName[segs$fault]
```


```{r}
segs <- segs %>%
   mutate(strike = case_when(strike > pi ~ strike - pi,
                             TRUE ~ strike))
```

```{r}
#| fig.width: 8
#| fig.height: 2
segs %>%
  # mutate(strike = cut(strike, c(0,1.7,2.5, pi), include.lowest = TRUE)) %>%
  ggplot() +
  geom_sf(aes(col = strike), linewidth = 2) +
  scale_color_viridis_c() +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
```
Find closest segment to each earthquake and use that for strike.
```{r}
segidx <- st_nearest_feature(s4df, segs)
strike_BSSL <- segs$strike[segidx, drop = TRUE]
s4df <- bind_cols(s4df, fstrike = strike_BSSL)
```

Below plots the assigned fault's strike (`fstrike`) closest to each earthquake

```{r}
#| fig.width: 8
#| fig.height: 2
segs %>%
  ggplot() +
  geom_sf(aes(col = strike), linewidth = 2) +
  geom_point(data = s4df,
    aes(x = Longitude, y = Latitude, fill = fstrike), 
    shape = 21,
    show.legend = FALSE) +
  scale_color_viridis_c(name = "Strike", limits = range(segs$strike)) +
  scale_fill_viridis_c(name = "Strike", limits = range(segs$strike)) +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
```

Strike looks correct.

```{r}
#| fig.width: 8
#| fig.height: 2
ggplot() +
  geom_sf(data = world) +
  geom_point(data = s4df, aes(x = Longitude, y = Latitude, col = dist/1000)) +
  geom_sf(show.legend = FALSE, data = filter(tecbound, NiceName == "BSSL")) +
  theme_bw() +
  scale_color_viridis_c(name = "Distance (km)", transform = "log10") +
  theme(axis.title = element_blank()) +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
```

# Look for Outliers
Below makes circles for plotting the edge of S^4 later.

```{r}
# Create data for the unit circle
theta <- seq(0, 2 * pi, length.out = 100)
circle_df <- data.frame(x = cos(theta), y = sin(theta))
colpairs <- #combn(paste0("Y", 1:5), 2, simplify = FALSE)
expand.grid(paste0("Y", 1:5), paste0("Y", 1:5)) %>%
  filter(Var1 != Var2) %>%
  mutate(Var1 = as.character(Var1), Var2 = as.character(Var2)) %>%
  rowwise() %>%
  mutate(pair = list(c(Var1, Var2))) %>%
  select(pair) %>%
  unlist(recursive = FALSE)
pair_dfs <- lapply(colpairs, function(pair) {
  Aname <- pair[1]
  Bname <- pair[2]
  circle_df %>%
    rename(A = x, B = y) %>%
    mutate(pair1=Aname,
           pair2=Bname,
           pair = paste(pair, collapse = "-"))
})
circle_df_long <- bind_rows(pair_dfs)
```

And the following is useful for paired plotting of locations on S4:

```{r}
pivot_coordpairs <- function(df, coordnames = paste0("Y",1:5), colpairs = colpairs <- combn(coordnames, 2, simplify = FALSE)){
  pair_dfs <- lapply(colpairs, function(pair) {
    Aname <- pair[1]
    Bname <- pair[2]
    df %>%
      # copy pair values
      mutate(A = .data[[Aname]],
             B = .data[[Bname]]) %>%
      mutate(pair1=Aname,
             pair2=Bname,
             pair = paste(pair, collapse = "-"))
  })
  pairsdf <- bind_rows(pair_dfs)
  pairsdf
}
pairedplotggprep <- function(df){
  ggplot(data = df, mapping = aes(x=A, y=B)) +
  facet_grid(vars(pair2), vars(pair1), switch = "both") +
  geom_path(data = ~(circle_df_long %>% filter(pair %in% .x$pair)),
            mapping = aes(x=A,y=B),
            inherit.aes = FALSE,
            color = "grey") +
  coord_fixed(xlim = c(-1.01,1.01), ylim = c(-1.01,1.01), expand = FALSE) +
  theme_minimal() +
  theme(strip.text.y = element_text(angle = 90),
        strip.placement = "outside",
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(), #element_line(arrow = grid::arrow(ends = "both", length = unit(0.1, "inches"))),
        panel.grid = element_blank())
}
```



```{r}
ystd <- s4df %>%
  st_drop_geometry() %>%
  select(s1, s2, sMrt, sMrf, sMtf) %>% 
  as.matrix() %>% 
  sphm:::standardise_sph()
colnames(ystd) <- paste0("Y", 1:5)
```

For easy plotting below, I've recorded the outliers I found.
```{r}
outliers <- c(
  "182" = "general",
  "306" = "general",
  "76" = "general",
  "254" = "general",
  "169" = "general",
  "87" = "general",
  "175" = "longitude",
  "260" = "longitude"
)
outliers <- outliers %>%
  tibble::enframe(name = "Number", value = "outlier") %>%
  mutate(Number = as.integer(Number))
```

## vs Longitude
In the below plot, moment tensors of earthquakes on $S^4$ are orthogonally projected onto pairs of axes.
Point colour is given by earthquake longitude.
Background colour is the average earthquake longitude for that part of projected $S^4$.

The axes Y1 ... Y5 have been chosen so that the second moment of the data is the identity.

```{r}
#| fig.width: 15
#| fig.height: 13
s4df %>%
  st_drop_geometry() %>%
  mutate(stdcoords = as_tibble(sphm:::standardise_sph(as.matrix(across(c(s1, s2, sMrt, sMrf, sMtf)))))) %>%
  tidyr::unnest_wider(stdcoords, names_sep = "") %>%
  rename_with(~gsub("stdcoordsV", "Y", .)) %>%
  left_join(outliers, by = "Number") %>%
  pivot_coordpairs(coordnames = paste0("Y", 1:5)) %>%
  pairedplotggprep() +
  stat_summary_2d(fun = mean,
                    aes(z = Longitude, fill = after_stat(value)),
                  bins = 10) +
  scale_fill_viridis_c() +
  geom_point(aes(fill = Longitude), size = 2, shape = 21) +
  ggrepel::geom_label_repel(aes(label = Number,
                                fontface = case_match(outlier, 
                                                      "general" ~ "plain",
                                                      "longitude" ~ "italic")
                                ),
                            data = ~filter(.x, !is.na(outlier)),
                            label.padding = 0.1,
                            min.segment.length = 0)
```

From these plots we can see 6 earthquakes very different to the rest in at least some of the coordinates Y1 - Y5.
Earthquakes 182, 306, 76, 87 and 169 were outlying in Y1.
Earthquake 254 is an outlier in Y5.

Furthermore, earthquake 175 is an outlier because it has a high longitude, but is located among low longitude earthquakes.
Earthquake 260 is similar.

Below is the same plotting method, without the outliers. The axes used for plotting are different because of the data has changed without the outliers.

```{r}
#| fig.width: 15
#| fig.height: 13
s4df %>%
  st_drop_geometry() %>%
  left_join(outliers, by = "Number") %>%
  filter(is.na(outlier)) %>%
  mutate(stdcoords = as_tibble(sphm:::standardise_sph(as.matrix(across(c(s1, s2, sMrt, sMrf, sMtf)))))) %>%
  tidyr::unnest_wider(stdcoords, names_sep = "") %>%
  rename_with(~gsub("stdcoordsV", "Y", .)) %>%
  mutate(outlier = case_when(Y2 < -0.75 ~ "new", TRUE ~ outlier)) %>%
  pivot_coordpairs(coordnames = paste0("Y", 1:5)) %>%
  pairedplotggprep() +
  stat_summary_2d(fun = mean,
                    aes(z = Longitude, fill = after_stat(value)),
                  bins = 10) +
  scale_fill_viridis_c() +
  geom_point(aes(fill = Longitude), size = 2, shape = 21) +
  ggrepel::geom_label_repel(aes(label = Number),
                            data = ~filter(.x, !is.na(outlier)),
                            label.padding = 0.1,
                            min.segment.length = 0)
```

Since removing the outliers identified by the Vs Longitude plot, Earthquake 93 is revealed as a possible outlier too. But we will leave it for this analysis.
There also appears to be a shift in earthquake moment tensors with longitude < 148 (blue) vs other earthquakes (green-yellow), which we will incorporate into regression later.

## vs Fault Strike
In the below plot, moment tensors of earthquakes on $S^4$ are orthogonally projected onto pairs of axes.
Point colour is given by fault strike.
Background colour is the average fault strike for that part of projected $S^4$.

The axes Y1 ... Y5 have been chosen so that the second moment of the data is the identity.

```{r}
#| fig.width: 15
#| fig.height: 13
s4df %>%
  st_drop_geometry() %>%
  left_join(outliers, by = "Number") %>%
  filter(is.na(outlier)) %>%
  mutate(stdcoords = as_tibble(sphm:::standardise_sph(as.matrix(across(c(s1, s2, sMrt, sMrf, sMtf)))))) %>%
  tidyr::unnest_wider(stdcoords, names_sep = "") %>%
  rename_with(~gsub("stdcoordsV", "Y", .)) %>%
  mutate(outlier = case_when(Y2 < -0.75 ~ "new", TRUE ~ outlier)) %>%
  pivot_coordpairs(coordnames = paste0("Y", 1:5)) %>%
  pairedplotggprep() +
  stat_summary_2d(fun = mean,
                    aes(z = fstrike, fill = after_stat(value)),
                  bins = 10) +
  scale_fill_viridis_c(name = "Fault Strike") +
  geom_point(aes(fill = fstrike), size = 2, shape = 21) +
  ggrepel::geom_label_repel(aes(label = Number),
                            data = ~filter(.x, !is.na(outlier)),
                            label.padding = 0.1,
                            min.segment.length = 0)
```

There could be two outliers with very low fault strike (dark blue) relative to other earthquakes, but fault strike doesn't seem to have as big an effect on moment tensors as longitude does.

# Figure for Paper
```{r}
#| fig.width: 7
#| fig.height: 2
ggplot() +
  geom_sf(data = world) +
  geom_point(data = s4df %>% left_join(outliers, by = "Number"),
             aes(x = Longitude, y = Latitude, shape = is.na(outlier)),
             position = position_jitter(width = 0.05, height = 0.05, seed = 1),
             show.legend = FALSE) +
  scale_shape_manual(values = c(4, 16)) +
  geom_sf(data = tecbound %>% filter(NiceName !="Other"), aes(lty = NiceName), show.legend = FALSE) +
  # geom_sf(data = regions %>% filter(region %in% 2:4), fill = NA, show.legend = FALSE) +
  scale_linetype_manual(values = c(NGT = "dashed", BSSL = "solid", Other = "dotted")) +
  theme_bw() +
  theme(axis.title = element_blank()) +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
ggsave("earthquakelocations.pdf", width = 7, height = 2)
```

# Remove Outliers
The outliers by region are:
```{r}
s4df %>%
  left_join(outliers, by = "Number") %>%
  filter(!is.na(outlier)) %>%
  st_drop_geometry() %>%
  select(Number, region) %>%
  arrange(region)
```


```{r}
s4df_clean <- s4df %>%
  left_join(outliers, by = "Number") %>%
  filter(is.na(outlier)) %>%
  mutate(outlier = case_when(Number == 93 ~ "possible", TRUE ~ outlier))
```

# Build covariates
Since dip has only two values 30 or 90, use it has a categorical variable.
Scale and center all Euclidean covariates to have mean 0 and sd of 1.

```{r}
xe <- s4df_clean %>%
  st_drop_geometry() %>%
  select(fstrike,
         Latitude, 
         Longitude) %>%
  # mutate(Longitude2 = Longitude^2) %>%
  mutate(L148 = Longitude < 148) %>%
  as.matrix()
xestd <- xe %>%
  scale() |>
  as_tibble()
cor(xe)
```

# vMF Regression
## Default start
```{r}
mod_vMF <- mobius_vMF(s4df_clean %>% 
                        select(s1, s2, sMrt, sMrf, sMtf) %>% 
                        st_drop_geometry() %>% 
                        as.matrix(),
                      xs = NULL, 
                      xe = xestd %>% as.matrix(),
                      type = "Shogo")
mod_vMF$k
mod_vMF$AIC
mod_vMF$DoF
```

## Random Starts
Here I tried 100 different starting points for the vMF regression. Below is a frequency polygon plot of the AIC all 100 estimates.

```{r}
#| eval: false
restarts <- pbapply::pblapply(1:100, function(seed){
  # randomly generates a Kassel-form link
  start <- sphm:::rmnlink_cann(p = 5, qs = 0, qe = ncol(xestd) + 2, preseed = seed)
  # convert to Shogo form:
  set.seed(seed+1)
  Qe <- mclust::randomOrthogonalMatrix(ncol(xestd)+1, 5-1)
  bigQe <- cbind(0, rbind(0, Qe))
  bigQe[, 1] <- 0
  bigQe[1,1] <- 1
  start$Qe <- bigQe
  start$ce <- 1
  mobius_vMF(s4df_clean %>% 
                          select(s1, s2, sMrt, sMrf, sMtf) %>% 
                          st_drop_geometry() %>% 
                          as.matrix(),
                        xs = NULL, 
                        xe = xestd %>% as.matrix(),
                        type = "Shogo",
                        start = start)
}, cl = 2)
lapply(restarts, "[[", "AIC") %>%
  unlist() %>%
  tibble::enframe("seed", "AIC") %>%
  ggplot()+
  geom_freqpoly(aes(x = AIC), bins = 30) +
  geom_vline(xintercept = mod_vMF$AIC, col = "blue") +
  geom_rug(aes(x = AIC))
```

No better vMF model was found.

# SvMF Regression
```{r}
mod_SvMF <- mobius_SvMF(s4df_clean %>% 
                        select(s1, s2, sMrt, sMrf, sMtf) %>% 
                        st_drop_geometry() %>% 
                        as.matrix(),
                      xs = NULL, 
                      xe = xestd %>% as.matrix(),
                      type = "Shogo",
                      G01behaviour = "free",
                      mean = mod_vMF$est)
mod_SvMF$k
mod_SvMF$AIC
mod_SvMF$a
mod_SvMF$DoF
```

The AIC of the SvMF regression is better (smaller) than the AIC of the vMF regression.

```{r}
cann <- sphm:::as_mnlink_cann(mod_SvMF$mean)
cann$Be
t(cann$Qe[,-1])
cann$Be %*% t(cann$Qe[,-1])
cann$P
```

# Predictions
```{r}
get_predobspairsdf <- function(mod,
                               extra = NULL,
                               colpairs = combn(paste0("Y",1:5), 2, simplify = FALSE)){
  # standard rotations
  ystd <- standardise_sph(mod$y)
  colnames(ystd) <- paste0("Y", 1:ncol(ystd))
  predstd <- standardise_sph(mod$pred, attr(ystd, "std_rotation"))
  colnames(predstd) <- paste0("p_Y", 1:ncol(predstd))
  # apply to p1 too
  p1std <- standardise_sph(matrix(mod$mean$p1, nrow = 1), attr(ystd, "std_rotation"))
  colnames(p1std) <- paste0("Y", 1:ncol(ystd))
  p1pairs <- as_tibble(p1std) %>%
    pivot_coordpairs(colpairs = colpairs)
  
  predsobs <- bind_cols(predstd,
                        ystd,
                        extra)
  pair_dfs <- lapply(colpairs, function(pair) {
    predsobs %>%
      select(everything(), -starts_with("Y"), -starts_with("p_Y"), all_of(pair),all_of(paste0("p_", pair))) %>%
      rename(A = last_col(3), B = last_col(2), p_A = last_col(1), p_B = last_col(0)) %>%
      mutate(pair1=pair[1],
             pair2=pair[2],
             pair = paste(pair, collapse = "-"))
  })
  pairsdf <- bind_rows(pair_dfs)
  attr(pairsdf, "p1") <- p1pairs
  pairsdf
}
```

```{r}
#| fig.width: 15
#| fig.height: 13
get_predobspairsdf(mod_SvMF, s4df_clean) %>%
  pairedplotggprep() +
  geom_segment(aes(x=p_A, y=p_B, xend=A, yend=B, col = Longitude),
               alpha = 0.5,
                arrow = grid::arrow(length = unit(0.02, "npc"))) +
  geom_point(aes(x=p_A, y=p_B, col = Longitude), size = 2) +
  geom_point(aes(x=A, y=B), size = 2, col = "blue",
             shape = 4,
             data = attr(get_predobspairsdf(mod_SvMF), "p1")) +
  ggrepel::geom_label_repel(aes(x=A, y=B, label = Number),
                            data = function(x) {x %>% filter(!is.na(outlier))},
                            size = 2, 
                            label.padding = 0.1,
                            min.segment.length = 0) +
  scale_color_viridis_c() +
  ggtitle("Prediction Highlighted")
```

# Predictions in Natural Coordinates

```{r}
get_predobspairsdf_nat <- function(mod,
                               extra = NULL,
                               colpairs = combn(c("s1", "s2", "sMrt", "sMrf", "sMtf"), 2, simplify = FALSE)){
  # apply to p1 too
  p1pairs <- tibble::as_tibble_row(mod$mean$p1) %>%
    pivot_coordpairs(colpairs = colpairs)
  
  predsobs <- bind_cols(mod$pred %>%
                          as_tibble() %>%
                          rename_with(~paste0("p_", .)),
                        mod$y,
                        extra)
  pair_dfs <- lapply(colpairs, function(pair) {
    predsobs %>%
      select(everything(), -starts_with("s"), -starts_with("p_s"), all_of(pair),all_of(paste0("p_", pair))) %>%
      rename(A = last_col(3), B = last_col(2), p_A = last_col(1), p_B = last_col(0)) %>%
      mutate(pair1=pair[1],
             pair2=pair[2],
             pair = paste(pair, collapse = "-"))
  })
  pairsdf <- bind_rows(pair_dfs)
  attr(pairsdf, "p1") <- p1pairs
  pairsdf
}
```

```{r}
#| fig.width: 15
#| fig.height: 13
get_predobspairsdf_nat(mod_SvMF, s4df_clean %>% select(-starts_with("s"))) %>%
  pairedplotggprep() +
  geom_segment(aes(x=p_A, y=p_B, xend=A, yend=B, col = Longitude),
               alpha = 0.5,
                arrow = grid::arrow(length = unit(0.02, "npc"))) +
  geom_point(aes(x=p_A, y=p_B, col = Longitude), size = 2) +
  geom_point(aes(x=A, y=B), size = 2, col = "blue",
             shape = 4,
             data = attr(get_predobspairsdf_nat(mod_SvMF), "p1")) +
  ggrepel::geom_label_repel(aes(x=A, y=B, label = Number),
                            data = function(x) {x %>% filter(!is.na(outlier))},
                            size = 2, 
                            label.padding = 0.1,
                            min.segment.length = 0) +
  scale_color_viridis_c() +
  ggtitle("Prediction Highlighted: natural coords")
```



# Paper Plot
```{r}
obsplots <- lapply(c("Y1-Y2", "Y3-Y2", "Y4-Y2"), function(pair){
  get_predobspairsdf(mod_SvMF, s4df_clean,
                     colpairs = strsplit(pair, "-")) %>%
    pairedplotggprep() +
    geom_point(aes(x=A, y=B, col = Longitude), size = 1) +
    scale_color_viridis_c() +
    theme(plot.margin = unit(c(0,2,0,2), "mm"),
          strip.text = element_text(margin = margin(0, 0, 0, 0)))
})
predplots <- lapply(c("Y1-Y2", "Y3-Y2", "Y4-Y2"), function(pair){
  get_predobspairsdf(mod_SvMF, s4df_clean,
                     colpairs = strsplit(pair, "-")) %>%
  pairedplotggprep() +
  geom_segment(aes(x=p_A, y=p_B, xend=A, yend=B, col = Longitude),
               alpha = 0.5,
                arrow = grid::arrow(length = unit(0.02, "npc"))) +
  geom_point(aes(x=p_A, y=p_B, fill = Longitude),
             size = 1.5,
             shape = 21) +
  geom_point(aes(x=A, y=B), size = 1, col = "blue",
             shape = 4,
             data = ~(attr(get_predobspairsdf(mod_SvMF, colpairs = strsplit(pair, "-")), "p1"))
             ) +
  scale_color_viridis_c() +
  scale_fill_viridis_c() +
  theme(plot.margin = unit(c(0,2,0,2), "mm"),
          strip.text = element_text(margin = margin(0, 0, 0, 0)))
})
( (obsplots[[1]] + 
     (obsplots[[2]]) + 
     (obsplots[[3]]) )/
  (predplots[[1]] + 
     (predplots[[2]]) + 
     (predplots[[3]])) ) + 
  plot_layout(guides = "collect") + 
  theme(legend.position = "bottom")
ggsave("earthquake_results.pdf", width = 7, height = 4)
```


Caption: 42 normalised earthquake moment tensors on $S^4$.
Moment tensors are shown orthoganally projected onto pairs of axes that standardise the observed earthquake moments to have mean of (1,0,0,0,0) with axes of variation Y2, Y3, Y4 and Y5 ordered by decreasing variance.
Plots of projections onto further pairs of axes are in SI.
Top: Observed earthquake moment tensors.
Bottom: Mean earthquake moment tensors according to our regression.
Colour: Longitude of earthquakes.
Arrows: represent residuals and point from mean earthquake moment tensor to the corresponding observed earthquake moment tensor.
Blue x: The location of the first column of $B_0$.
Grey circle boundary: intersection of $S^4$ with the plane given by the pair of axes.

# Residuals
Here we present the residuals more thorougly.

## Paired Plots

Here we plot the the residuals against each of the axes defined by $\Gamma_0$. We can see the ellipsiodal nature of Scaled von Mises Fisher residuals.

```{r}
#| fig.width: 8
#| fig.height: 7
circle_df_long <- circle_df_long %>%
  mutate(across(starts_with("pair"), ~gsub("Y", "r", .x)))
mod_SvMF$rresids_G0 %>%
  as_tibble() %>%
  bind_cols(s4df_clean) %>%
  pivot_coordpairs(coordnames = paste0("r", 1:4)) %>%
  pairedplotggprep() +
  stat_summary_2d(fun = mean, 
                  aes(z = Longitude, fill = after_stat(value)),
                  bins = 10) +
  geom_point(aes(fill = Longitude), size = 2, shape = 21) +
  scale_fill_viridis_c(name = "Longitude") +
  scale_color_viridis_c(name = "Longitude")
```

Here the same residuals are transformed using the estimated concentration and Scale von Mises Fisher scales so that at high-concentrations the residuals should be close to a standard multivariate Normal.

```{r}
#| fig.width: 6
#| fig.height: 5
mod_SvMF$rresids_std %>%
  as_tibble() %>%
  bind_cols(s4df_clean) %>%
  pivot_coordpairs(coordnames = paste0("r", 1:4)) %>%
  ggplot(mapping = aes(x=A, y=B)) + 
  facet_wrap(vars(pair2, pair1)) +
  theme(strip.text.y = element_text(angle = 90),
        strip.placement = "outside",
        axis.title = element_blank(),
        strip.background = element_blank()) +
  geom_hline(yintercept = 0, lty = "dashed") +
  geom_vline(xintercept = 0, lty = "dashed") +
  geom_point(size = 1) +
  scale_fill_viridis_c() +
  coord_fixed()
```

## Residual Distance by Covariate
```{r}
p1 <- bind_cols(rdist = mod_SvMF$dists, s4df_clean) %>%
  ggplot(aes(x=rdist, y = Longitude)) +
  geom_point() +
  ggrepel::geom_label_repel(aes(label = Number),
                           size = 2,
                           data = function(x) {filter(x, !is.na(outlier))}, min.segment.length = 0.01)

p2 <- bind_cols(rdist = mod_SvMF$dists, s4df_clean) %>%
  ggplot(aes(x=rdist, y = fstrike)) +
  geom_point() +
  ggrepel::geom_label_repel(aes(label = Number),
                           size = 2,
                           data = function(x) {filter(x, !is.na(outlier))}, min.segment.length = 0.01)
p1 + p2
```

Left panel: There is some suggestion of increasing residual size with longitude, except that two earthquakes on the top left and bottom right might suggest otherwise.
Right panel: No indication that fault strike is related to residual size.
The possible outlier Earthquake 93 does not have an outlying residual.

## Residual per G0 Axis by Covariate
```{r}
bind_cols(mod_SvMF$rresids_G0, s4df_clean) %>%
  st_drop_geometry() %>%
  tidyr::pivot_longer(matches("^r.$"), names_to = "raxis", values_to = "value") %>%
  tidyr::pivot_longer(c(Longitude, fstrike), names_to = "covariate", values_to = "cvalue") %>%
  ggplot(aes(x = cvalue, y = value)) +
  facet_grid(rows = vars(raxis), cols = vars(covariate), scales = "free") +
  geom_hline(yintercept = 0, col = "blue", lty = "dashed") +
  geom_smooth(method = "loess", formula = 'y ~ x') +
  geom_point()
```

The residuals appear to be be centered on zero.


# Likelihood Ratio Test of vMF vs SvMF
```{r}
getlikR <- function(y){
  mod1 <- mobius_vMF(y,
                     xs = NULL, 
                     xe = mod_vMF$xe,
                     type = "Shogo",
                     start = mod_vMF$est)
  mod2 <- withCallingHandlers({mobius_SvMF(y,
                      xs = NULL, 
                      xe = mod_vMF$xe,
                      type = "Shogo",
                      G01behaviour = "free",
                      mean = mod_SvMF$mean,
                      k = mod_SvMF$k,
                      a = mod_SvMF$a,
                      G0 = mod_SvMF$G0)},
        warning = function(w){
        if (grepl("p!=3", conditionMessage(w))) {
          invokeRestart("muffleWarning")
        }
      })
  lLik1 <- sphm:::dS2S_constV(mod1$y, xs = NULL, xe =mod1$xe,
              mean = mod1$est,
              k = mod1$k,
              a = rep(1, 5),
              G0 = mod2$G0) %>%
    colSums()
  lLik2 <- sphm:::dS2S_constV(mod2$y, xs = NULL, xe =mod2$xe,
              mean = mod2$mean,
              k = mod2$k,
              a = mod2$a,
              G0 = mod2$G0) %>%
    colSums()

  # I'm going to use the R version because it will calculate things more accurately
  list(likR = -2* (lLik1[["R"]] - lLik2[["R"]]),
       vMF = mod1,
       SvMF = mod2)
}
null_likRs <- pbapply::pblapply(1:1000, function(seed){
  set.seed(seed)
  y_ld <- sphm:::rS2S_constV(xs = NULL, 
                   xe = mod_vMF$xe,
                   mnparam = mod_vMF$est,
                   k = mod_vMF$k,
                   a = rep(1, 5),
                   G0 = diag(1,5))
  sum(y_ld[,6])
  y <- y_ld[,-6]
  getlikR(y)
})
obs <- getlikR(s4df_clean %>% 
                        select(s1, s2, sMrt, sMrf, sMtf) %>% 
                        st_drop_geometry() %>% 
                        as.matrix())
```

P-value is the probability, under the null, of getting a likelihood-ratio that is at least as large as the observed ratio:

```{r}
mean(obs$likR < lapply(null_likRs, "[[", "likR") %>% unlist())
```

The likelihood ratio is larger than any simulated data from the null (vMF model) achieves. Suggesting the data does not come from the vMF model.

# Parametric Bootstrap Regions for `a`
Since a vMF model is rejected, lets look at CI that for the fitted SvMF.

```{r}
Bests <- pbapply::pblapply(1:1000, function(seed){
  set.seed(seed)
  y <- sphm:::rS2S_constV(xs = NULL, 
                   xe = mod_SvMF$xe,
                   mnparam = mod_SvMF$mean,
                   k = mod_SvMF$k,
                   a = mod_SvMF$a,
                   G0 = mod_SvMF$G0)[,-6]
  newmod <- withCallingHandlers({mobius_SvMF(y,
                      xs = NULL, 
                      xe = mod_vMF$xe,
                      type = "Shogo",
                      G01behaviour = "free",
                      mean = mod_SvMF$mean,
                      k = mod_SvMF$k,
                      a = mod_SvMF$a,
                      G0 = mod_SvMF$G0)},
          warning = function(w){
        if (grepl("p!=3", conditionMessage(w))) {
          invokeRestart("muffleWarning")
        }
      })
  return(newmod[c("mean", "k", "a", "G0")])
}, cl = 2)
```


```{r}
Bests_a <- lapply(Bests, "[[", "a") %>%
  simplify2array() %>%
  t()
colnames(Bests_a) <- paste0("a", 1:5)
summary(Bests_a)
```

### 95% CI for a
```{r}
apply(Bests_a[,-1], 2, quantile, probs = c(0.025, 0.975)) %>%
  round(2)
```

a2 stays a long way from 1 and a5 is always smaller than 0.6.

# LOOCV MSE
```{r}
loocvmseSvMF <- function(mod){
  stopifnot(inherits(mod$mean, "mnlink_Omega"))
  dists <- pbapply::pblapply(1:nrow(mod$y), function(idx){
    newmod <- 
      withCallingHandlers({
      sphm:::optim_constV(mod$y[-idx,],
                xs = mod$xs[-idx,],
                xe = mod$xe[-idx,c(-1,-ncol(mod$xe)), drop = FALSE],
                fix_qs1 = FALSE,
                type = "Shogo",
                G01behaviour = "free",
                mean = mod$mean,
                k = mod$k,
                a = mod$a,
                G0 = mod$G0)},
      warning = function(w){
        if (grepl("p!=3", conditionMessage(w))) {
          invokeRestart("muffleWarning")
        }
      })
    pred <- mnlink(xs = mod$xs[idx,, drop = FALSE],
                   xe = mod$xe[idx,, drop = FALSE],
                   param = newmod$mean)
    obs <- mod$y[idx,]
    Euc <- sphm:::vnorm(drop(obs - pred))
    angle <- acos(rowSums(obs * pred))
    return(c(
      Euc = Euc,
      angle = angle
    ))
  })
  dists <- dists %>%
    simplify2array() %>%
    t() %>%
    as_tibble()
  dists %>%
    summarise(across(everything(), ~sum(.x^2)/nrow(mod$y)))
}
loocvmseSvMF(mod_SvMF)
```

More stable is to only do the `optim_constV()` step. MSE is slightly better than regions. But not heaps.


# Discrete Mean Models
Instead of a regression, just use the regional mean, where regions defined by longitude.

```{r}
regionalmeans <- function(y, Longitude, breaks){
  y <- as_tibble(y)
  Longfctr <- cut(Longitude, breaks = breaks, include.lowest = TRUE, dig.lab = 4)
  groups <- split(y, Longfctr)
  means <- lapply(groups, function(df){
    mn <- colMeans(df)
    mn <- mn/sphm:::vnorm(mn)
    mn
  })
  return(list(means = means,
              y = y,
              Longitude = Longitude,
              breaks = breaks))
}
mod_3regions <- regionalmeans(
  y = s4df_clean %>%
  select(s1,s2,sMrt,sMrf,sMtf) %>%
  st_drop_geometry(),
  Longitude = s4df_clean$Longitude,
  breaks = c(144,147.3,150.3,152.5)
)
mod_2regions <- regionalmeans(
  y = s4df_clean %>%
  select(s1,s2,sMrt,sMrf,sMtf) %>%
  st_drop_geometry(),
  Longitude = s4df_clean$Longitude,
  breaks = c(144,148,152.5)
)
```

## LOOCV MSE
```{r}
loocvmseRegionMeans <- function(mod){
  dists <- pbapply::pblapply(1:nrow(mod$y), function(idx){
    newmod <- regionalmeans(y = mod$y[-idx,, drop = FALSE],
                            Longitude = mod$Longitude[-idx],
                            breaks = mod$breaks)
    # prediction
    region <- cut(mod$Longitude[idx], breaks = newmod$breaks, dig.lab = 4)
    pred <- newmod$means[[region]]
    obs <- unlist(as.vector(mod$y[idx,]))
    Euc <- sphm:::vnorm(drop(obs - pred))
    angle <- acos(sum(obs * pred))
    return(c(
      Euc = Euc,
      angle = angle
    ))
  })
  dists <- dists %>%
    simplify2array() %>%
    t() %>%
    as_tibble()
  dists %>%
    summarise(across(everything(), ~sum(.x^2)/nrow(mod$y)))
}
loocvmseRegionMeans(mod_3regions)
loocvmseRegionMeans(mod_2regions)
```

Mean squared error is great compared to Rosenthal's PLT!


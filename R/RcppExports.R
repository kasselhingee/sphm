# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

Omega_constraints <- function(vec, p, qe = 0L) {
    .Call(`_sphm_Omega_constraints`, vec, p, qe)
}

#' The unnormalised log-likelihood of a SvMF Sphere-Sphere Regression with Mobius Mean Link and Variance Axes Aligned with P.
#' @description Three functions in a format compatible with `tapefun`. A difficulty is that the P matrix needs and SVD to get out of the Omega parameterisation so two functions for alternating between optimising the mean (with `kappa` and `a` fixed, and `G` aligned to a fixed `P`) and optimising a, with the mean fixed and concentration fixed, and updating `P` inbetween.
#' @param vec For `_alignedG_mean`: A parameter vector specifying the mean via the Omega vectorisation.
#' @param dyn For `_alignedG_mean`: A p+1+p*p length vector of kappa, then a1, a2, ..., then P as a vector of stacked columns.
#' @param p_in The dimension p
#' @param yx The observations and covariates cbind together as row vectors
ull_S2S_alignedG_mean <- function(vec, dyn, p_in, yx) {
    .Call(`_sphm_ull_S2S_alignedG_mean`, vec, dyn, p_in, yx)
}

#' @param vec For `_alignedG_a`: A p-2 vector of log(a3), log(a4), log(a5), ... log(a2) will be calculated as the negative sum of the others to satisfy the prod=1 constraint on a2,...
#' @param dyn For `_alignedG_a`: A vector of kappa then a1
#' @param pOmegavec For `_alignedG_a`: A vector of p then the Omega vectorisation, then `as.vector(P)`. Due to an SVD to extract P from Omega vec, taping the dependence on Omega would be unreliable. Furthermore R's SVD routine seems more reliable than Eigen's.
ull_S2S_alignedG_a <- function(vec, dyn, pOmegavecP, yx) {
    .Call(`_sphm_ull_S2S_alignedG_a`, vec, dyn, pOmegavecP, yx)
}

#' @param k For `_alignedG_k`: A parameter vector specifying the concentration k
#' @param dyn For `_alignedG_k`: A p*q + p + p*p length vector of Omegavec, then a1, a2, ..., then P as a vector of stacked columns.
#' The P and Omega are provided seperately because of the non-smooth nature of SVD.
ull_S2S_alignedG_k <- function(k, dyn, p_in, yx) {
    .Call(`_sphm_ull_S2S_alignedG_k`, k, dyn, p_in, yx)
}

#' @describeIn ull_S2S_alignedG_mean Aligns the columns of the Mobius-link rotation matrix `P` for the mean to the columns of G. Note that the first column of the returned G is the given mean. Returns the matrix G.
alignedGcpp <- function(m, P) {
    .Call(`_sphm_alignedGcpp`, m, P)
}

cayleyTransform <- function(A) {
    .Call(`_sphm_cayleyTransform`, A)
}

inverseCayleyTransform <- function(M) {
    .Call(`_sphm_inverseCayleyTransform`, M)
}

vectorizeLowerTriangle <- function(A) {
    .Call(`_sphm_vectorizeLowerTriangle`, A)
}

inverseVectorizeLowerTriangle <- function(vec) {
    .Call(`_sphm_inverseVectorizeLowerTriangle`, vec)
}

#' @title Convert all SvMF regression parameters into a single long vector
#' @description Placing all parameters in a single vector allow automatic differentiation with the parameters as independent values. Some tidying of the parameter space also occurs in the vectorisation.
#' @details The scales `aremaining` are constrained to have a product of `1` and be positive. This function encodes these restrictions by dropping the first element of `aremaining` and converting the other elements to \eqn{log(a_j)} etc.
#' @param G0 are the orientation axes of SvMF in cannonical coordinate (p x p matrix). Ideally G0 is close to the referencecoords axes. G0 must be a rotation matrix (det > 0) so that the Cayley transform representation works.
#' @param referencecoords is a p x p orthonormal matrix specifying the reference coordinates for the Cayley transforms. It is best if referencecoords is close to the best G0 (so rG0 is close the identity) and it will fail if `G01` is the antepode of `referencoords[,1]`.
S2S_constV_nota1_tovecparams <- function(omvec, k, aremaining, G0, referencecoords, G01behaviour) {
    .Call(`_sphm_S2S_constV_nota1_tovecparams`, omvec, k, aremaining, G0, referencecoords, G01behaviour)
}

S2S_constV_nota1_fromvecparamsR <- function(mainvec, p, qs, qe, referencecoords, G01behaviour, G01 = NULL) {
    .Call(`_sphm_S2S_constV_nota1_fromvecparamsR`, mainvec, p, qs, qe, referencecoords, G01behaviour, G01)
}

ull_S2S_constV_forR <- function(y, xs, xe, omvec, k, a1, aremaining, G0) {
    .Call(`_sphm_ull_S2S_constV_forR`, y, xs, xe, omvec, k, a1, aremaining, G0)
}

tape_ull_S2S_constV_nota1 <- function(omvec, k, a1, aremaining, G0star, p_in, qe_in, yx, referencecoords, G01behaviour) {
    .Call(`_sphm_tape_ull_S2S_constV_nota1`, omvec, k, a1, aremaining, G0star, p_in, qe_in, yx, referencecoords, G01behaviour)
}

mnlink_cpp <- function(xs, xe, vec, p) {
    .Call(`_sphm_mnlink_cpp`, xs, xe, vec, p)
}

#' Preliminary Objective in the style of the `generalfunction` class:
#' @param yx is the response the spherical covariates, and the Euclidean covariates *cbind* together. Each row an observation.
#' @param dyn is a zero length vector that is ignored
#' @param dims_in A vector of `c(p, qe)`. `p` and `qe` are required to separate yx and omvec into their constituents.
#' @details
#' The return is vector of mu.y values where mu is the mean predicted by omvec and x, and y are the observations.
#' This mu.y is (log(vMF density) - log(vMF norm const(k)))/k.
#' Therefore the gradient of below function, for each return value, is: grad(mu.y) = grad(log(vMF density))/k
#' The Fisher information matrix ignoring concentration is var(grad(log(vMF density))) = k^2 var(grad(mu.y)).
#' So standard errors for the preliminary mean require knowledge of the concentration parameter k.
prelimobj_cpp <- function(omvec, dyn, dims_in, yx) {
    .Call(`_sphm_prelimobj_cpp`, omvec, dyn, dims_in, yx)
}

#' Function to create tapes of besselImixed() from uldSvMF purely for testing differentiation
tape_besselImixed <- function(x, nu, threshold, order, log_result = TRUE) {
    .Call(`_sphm_tape_besselImixed`, x, nu, threshold, order, log_result)
}

#' @noRd
#' @title Function for taping a general function. 
#' @description The function must have signature
#' `veca1 fun(const veca1 & independent, const veca2 & dynamic, const vecd & constvec, const matd & constmat)`.
#' Differentiation of `fun` will occur with respect to the independent arguments. The taping will keep of dependence on the dynamic arguments so that the value of the dynamic arguments can be changed in the tape. The constants (constvec and constmat) will be baked into the tape (to change these constants `tapefun` will have to be called again.
#' 
#' If some of the arguments are unwanted, I'm hoping I can write the function so that vectors of length zero are okay.
#'
#' @param fun A function with the correct signature.
#' @param ind_t The value of the independent argument to use for taping.
#' @param dyn_t The value of the dynamic argument to use for taping.
#' @param constants The value of the constants argument.
#' @param check_for_nan Should the tape watch for nan values when in use? This can be useful to let the tape pass nan back to R
NULL

#' Tape using a function name in function_map 
#' @param func_name Name of function to tape. Name must be in the internal `function_map` object.
tape_namedfun <- function(func_name, ind_t, dyn_t, constvec, constmat, check_for_nan) {
    .Call(`_sphm_tape_namedfun`, func_name, ind_t, dyn_t, constvec, constmat, check_for_nan)
}

#' Helper function Bessel I approximation from BesselI::besselIasym()
#' which should be from Asymptotic expansion of Bessel I_nu(x) function   x -> oo
#'       by Abramowitz & Stegun (9.7.1), p.377 
#' I_a(z) = exp(z) / sqrt(2*pi*z) * f(z,..)  where
#'   f(z,..) = 1 - (mu-1)/ (8*z) + (mu-1)(mu-9)/(2! (8z)^2) - ...
#'           = 1- (mu-1)/(8z)*(1- (mu-9)/(2(8z))*(1-(mu-25)/(3(8z))*..))
#' where  mu = 4*a^2  *and*  |arg(z)| < pi/2
#' This is useful for large x
#' @param x is the vMF concentration parameter
#' @param nu is such that nu + 1 = d/2, where d is the ambient dimension of the sphere.
besselIasym <- function(x, nu, order, log_result = TRUE) {
    .Call(`_sphm_besselIasym`, x, nu, order, log_result)
}

#' For small x (i.e. concentration) Hornik and Grun use simple relation by Schou 1979 (and others)
#' for approximating the derivative of log(const(k)) but I want a coarse idea of the value here.
#' I'm going to use the series 10.25.2 from Nist: `https://dlmf.nist.gov/10.25#E2`
#' This looks actually to be just a solution to equation defining the modified Bessel function.
#' (x/2)^nu sum_i{1/i! 1/gamma(nu + i + 1) (x/2)^(2i)}.
#' nu and order are NOT differentiable
#' @param order Maximum order of series to compute
besselItrunc <- function(x, nu, order, log_result = TRUE) {
    .Call(`_sphm_besselItrunc`, x, nu, order, log_result)
}

#' Helper function lvMFnormconst_approx
#' For p == 3 using an exact formula
#' Otherwise uses *approximations* of the modified Bessel function of the first order.
#' The normalising constant is \eqn{(2 * \pi)^{p/2} besselI(k, p/2 - 1)/k^{p/2 -1}}
#' where \eqn{p} is the dimension of the ambient space of the sphere (i.e. vectors have \eqn{p} entries)
#' @details
#' Returns the log of the normalising constant.
#' The approximation uses a threshold of 10 to choose between the small concentration and large concentration regime,
#' and in each regime the series order used is 15.
lvMFnormconst_approx <- function(kappa, p) {
    .Call(`_sphm_lvMFnormconst_approx`, kappa, p)
}

uldSvMF_cann <- function(y, k, a, G) {
    .Call(`_sphm_uldSvMF_cann`, y, k, a, G)
}

uldSvMF_muV <- function(y, k, m, a1, V) {
    .Call(`_sphm_uldSvMF_muV`, y, k, m, a1, V)
}

#' @noRd
#' @description
#' This function approximates the BesselI function by
#' using `BesselItrunc()` for values of `x` smaller than `threshold` and
#' using `BesselIasym()` for values of `x` larger than `threshold`.
#' @param x value to compute the BesselI function at.
#' @param nu The `nu` in the BesselI function.
#' @param order The order of approximation to use in `BesselItrunc()` and `BesselIasym()`
#' @param threshold is the location at which the calculation switches
#' @param log_result Whether to return the log of the approximated BesselI function. This is useful to avoid floating point over run or inaccuracies.
#' @return a single value
besselImixed <- function(x, nu, threshold, order, log_result = TRUE) {
    .Call(`_sphm_besselImixed`, x, nu, threshold, order, log_result)
}

#' @param Vvec Vectorised form of matrix V ala vech
#' @param yk vector of y values, then the k. Will be dynamic parameters because the 'y' may be residuals and be updated frequently
#' @param a1m The tuning parameter a1 and the mean, which will often be the northpole
ull_SvMF_V <- function(Vvec, yk, a1m) {
    .Call(`_sphm_ull_SvMF_V`, Vvec, yk, a1m)
}


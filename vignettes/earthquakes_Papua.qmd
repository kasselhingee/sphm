---
title: "Mobius Regression of Earthquake Moment Tensors"
subtitle: "Shallow Earthquakes Regions 2 - 4"
author: "Kassel Hingee"
format:
  pdf:
    toc: true
    number-sections: true
    fig-width: 6.5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(ggplot2)
library(dplyr)
library(GGally)
library(patchwork)
library(sphm)
packageVersion("sphm")
```

# Raw Data
This data is copied directly from Hejrani et al (2017) Table 1.

```{r}
raw=read.table(file="./papua20240709.csv",
               header=T,sep=",", numerals = "warn.loss",
               colClasses = c(Origin.Time = "character"))
head(raw) %>%
  mutate(Origin.Time = paste0(substr(`Origin.Time`, 1, 6),"..")) %>%
  rename(Lon = Longitude,
         Lat = Latitude) %>%
  knitr::kable() %>%
  kableExtra::kable_styling(font_size = 8)
```

In this raw data:

+ `Origin.Time`. Hejrani references the GCMT project for origin times. Though not explicitly in Hejrani et al (2017), it seems this column is the format that GCMT uses for modern earthquakes, which is XYYYYMMDDhhmmZ where X is the type of data used, Z is for distinguishing events at the same time (day?) and the stuff in between ti time.
+ `Number` relates uniquely to increasing origin time.
+ `Lon` and `Lat` are the Longitude and Latitude of the earthquake
+ `Depth` is the depth (in kilometres) of the earthquake
+ `M**` are scaled elements of the earthquake moment tensors where `r`, `t`, `f` represent basis directions.
+ `Mw * 10^Exp` is a magnitude.
+ `Dcper` is related to how close the earthquake is a to a pure double-couple.

For later lets record the names of the `M**` columns in the same order as the symmetric-matrix vectorisation function `vech`:

```{r}
elementnames <- c("Mrr", "Mrt", "Mrf",
                  "Mtt", "Mtf",
                  "Mff")
```

# Transform to $S^4$
## Enforce Trace=0 and Scale=1
The moment tensors have traces that nearly 0.

```{r}
traces <- rowSums(raw[, c("Mrr", "Mtt", "Mff")])
traces %>%
  tibble::enframe(value = "trace") %>%
  ggplot() +
  geom_histogram(aes(x = trace)) +
  geom_rug(aes(x = trace))
```

Here I'll make the trace exactly zero.

```{r}
stddf <- raw %>%
  mutate(Mff = -Mrr - Mtt)
```

Now we scale the moment tensors to have a Frobenius norm of 1. The function `gettr2()` below is fast way to compute the square of the Frobenius norm without winding the 6 `M**` columns up into individual 3 x 3 matrices.
```{r tr2}
gettr2 <- function(ms){
  I2 <- ms[, 1] * ms[, 4] + ms[, 4] * ms[, 6] + ms[,1] * ms[,6] -
    ms[, 2]^2 - ms[, 5]^2 - ms[,3]^2
  I1 <- ms[, 1] + ms[, 4] + ms[, 6] #trace
  tr2 <- I1^2 - 2*I2
  return(tr2)
}
Fnorm <- sqrt(gettr2(stddf[, elementnames]))
stddf <- stddf %>%
  mutate(Fnorm = Fnorm) %>%
  mutate(across(starts_with("M"), ~.x/Fnorm))
```

Lets verify the result of these transformations on the first earthquake.

```{r}
elementvalues <- unlist(stddf[1, elementnames])
tmpM <- matrix(NA, 3, 3)
tmpM[lower.tri(tmpM, diag = TRUE)] <- elementvalues
tmpM[upper.tri(tmpM)] <- t(tmpM)[upper.tri(tmpM)]
colnames(tmpM) <- rownames(tmpM) <- c("r", "t", "f")

elementvalues
tmpM
sqrt(sum(tmpM^2))
sum(diag(tmpM))
```

The trace and norm are exactly 0 and 1 as desired.

## Moment Tensors as Unit Vectors in $R^5$
The diagonal elements must sum to zero, which puts them on a plane through the origin.
I'll use the Helmert submatrix to express these diagonal elements with respect to an orthonormal basis on this plane. The plane is two dimensions, so I'll call these new coordinates `s1` and `s2`.

```{r}
H <- rbind(c(1,-1, 0), c(1,1,-2))
H <- H/sqrt(rowSums(H^2))
diagproj <- t(H %*% t(stddf[, c("Mrr", "Mtt", "Mff")]))
colnames(diagproj) <- c("s1", "s2")
```

I'll scale the off diagonal elements by $\sqrt{2}$ because off-diagonal elements are counted twice in the Frobenius norm.

```{r}
offdiag <- stddf %>%
  mutate(sMrt = sqrt(2) * Mrt,
         sMrf = sqrt(2) * Mrf,
         sMtf = sqrt(2) * Mtf) %>%
  select(sMrt, sMrf, sMtf)
```

Combined these are unit vectors in $R^5$
```{r}
sqrt(rowSums(cbind(diagproj, offdiag)^2))
```

Lets combine back into full data frame
```{r}
s4df <- bind_cols(diagproj, offdiag, raw)
```

# Hejrani et al (2017)'s Regions
Here I have captured the regions from Fig 16 of Hejrani et al (2017) by visual assessment.
```{r}
library(sf)
ptmatrix <- function(xmin, xmax, ymin, ymax){
  matrix(c(xmin, ymax,   
           xmax, ymax,
           xmax, ymin,
           xmin, ymin,
           xmin, ymax), byrow = TRUE, ncol = 2)
}

regions <- st_sfc(st_polygon(list(ptmatrix(141, 144, -4, -2))),
                  st_polygon(list(ptmatrix(144, 147.3, -4, -2))),
                  st_polygon(list(ptmatrix(147.3, 150.3, -4, -2.5))),
                  st_polygon(list(ptmatrix(150.3, 152.5, -4.1, -3))),
                  st_polygon(list(ptmatrix(146.1, 151.5, -7.1, -5.7))),
                  st_polygon(list(ptmatrix(151.5, 153.5, -6.8, -4.7))),
                  st_polygon(list(ptmatrix(153.5, 156.7, -8.5, -5))),
                  st_polygon(list(ptmatrix(156.7, 159, -10, -8))),
       crs = 4326)
regions <- st_sf(region = factor(1:8, ordered = TRUE), geom = regions)
```

# Keep Only Shallow Eartquakes in Regions 2-4
Convert data into an `sf` object. Assuming that the longitude and latitude are using the GPS coordinate system.

```{r}
s4df <- sf::st_as_sf(s4df, coords = c("Longitude", "Latitude"), remove = FALSE)
sf::st_crs(s4df) <- 4326
s4df <- st_intersection(s4df, regions) 
s4df <- mutate(s4df, region = as.factor(region))
s4df <- s4df %>% 
  filter(region %in% 2:4) %>%
  filter(Depth <= 20)
nrow(s4df)
```

# $S^4$ Plot Helpers
Below makes circles for plotting the edge of S^4 later.

```{r}
# Create data for the unit circle
theta <- seq(0, 2 * pi, length.out = 100)
circle_df <- data.frame(x = cos(theta), y = sin(theta))
colpairs <- #combn(paste0("Y", 1:5), 2, simplify = FALSE)
expand.grid(paste0("Y", 1:5), paste0("Y", 1:5)) %>%
  filter(Var1 != Var2) %>%
  mutate(Var1 = as.character(Var1), Var2 = as.character(Var2)) %>%
  rowwise() %>%
  mutate(pair = list(c(Var1, Var2))) %>%
  select(pair) %>%
  unlist(recursive = FALSE)
pair_dfs <- lapply(colpairs, function(pair) {
  Aname <- pair[1]
  Bname <- pair[2]
  circle_df %>%
    rename(A = x, B = y) %>%
    mutate(pair1=Aname,
           pair2=Bname,
           pair = paste(pair, collapse = "-"))
})
circle_df_long <- bind_rows(pair_dfs)
```

And the following is useful for orthogonal projection of locations on to pairs of axes:

```{r}
pivot_coordpairs <- function(df, coordnames = paste0("Y",1:5), colpairs = combn(coordnames, 2, simplify = FALSE)){
  pair_dfs <- lapply(colpairs, function(pair) {
    Aname <- pair[1]
    Bname <- pair[2]
    df %>%
      # copy pair values
      mutate(A = .data[[Aname]],
             B = .data[[Bname]]) %>%
      mutate(pair1=Aname,
             pair2=Bname,
             pair = paste(pair, collapse = "-"))
  })
  pairsdf <- bind_rows(pair_dfs)
  attr(pairsdf, "coordnames") <- coordnames
  pairsdf
}
pairedplotggprep <- function(df){
  # rename circle_df_long to coordnames
  dict <- attr(df, "coordnames")
  names(dict) <-  paste0("Y", 1:length(dict))
  circle_df_long <- circle_df_long %>%
    mutate(
      pair1 = dict[pair1],
      pair2 = dict[pair2],
      pair = paste0(pair1,"-",pair2))
  
  # nicer strip labels
  label_map <- c(
    s1 = "(Mrr - Mtt)/sqrt(2)",
    s2 = "(Mrr + Mtt - 2*Mff)/sqrt(6)",
    sMrt = "Mrt / sqrt(2)",
    sMrf = "Mrf / sqrt(2)",
    sMtf = "Mtf / sqrt(2)",
    Y1 = "Y1",
    Y2 = "Y2",
    Y3 = "Y3",
    Y4 = "Y4",
    Y5 = "Y5"
  )
  
  #now do plotting prep
  ggplot(data = df, mapping = aes(x=A, y=B)) +
  facet_grid(vars(pair2), vars(pair1), switch = "both", labeller = as_labeller(label_map, label_parsed)) +
  geom_path(data = ~(circle_df_long %>% filter(pair %in% .x$pair)),
            mapping = aes(x=A,y=B),
            inherit.aes = FALSE,
            color = "grey") +
  coord_fixed(xlim = c(-1.01,1.01), ylim = c(-1.01,1.01), expand = FALSE) +
  theme_minimal() +
  theme(strip.text.y = element_text(angle = 90),
        strip.placement = "outside",
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_line(arrow = grid::arrow(type = "closed", angle = 10, length = unit(10, "points")),
                                 linewidth = 0.2),
        panel.grid = element_blank(),
        legend.position = "bottom")
}
```


# SI Figure: Earthquake Moment Tensors Paired Plots
```{r}
#| fig.width: 12
#| fig.height: 13
s4df %>%
  pivot_coordpairs(coordnames = c("s1", "s2", "sMrf", "sMrt", "sMtf")) %>%
  pairedplotggprep() +
  geom_point(aes(col = Longitude)) +
  scale_shape_manual(guide = "none", values = c(4, 16)) +
  scale_color_viridis_c()
```

# Fault distance and strike
For each earthquake we find the distance to the BSSL and also the strike (up to $\pm \pi$) of the fault at this closest point.
For BSSL, the fault plane is vertical so strike may as well be below $\pi$.

## Distance to BSSL
Plate information was obtained from github `https://github.com/fraxen/tectonicplates`.

```{r}
#| eval: false
tmp <- paste0("https://github.com/fraxen/tectonicplates/raw/refs/heads/master/PB2002_boundaries.", c("dbf", "prj", "sbn", "sbx", "shp", "shp.xml", "shx")) |>
  lapply(function(x){download.file(x, basename(x))})
```

```{r}
library(sf)
library("rnaturalearth")
world <- ne_countries(scale = "medium", returnclass = "sf")
tecbound <- st_read("PB2002_boundaries.shp")
mat <- st_intersects(tecbound, st_as_sfc(st_bbox(s4df)))
tecbound <- tecbound[apply(mat, 1, any), ]
tecbound <- tecbound %>%
  mutate(NiceName = case_match(
    Name,
    "NB-SB" ~ "BSSL",
    "NB-MN" ~ "BSSL",
    "MN-SB" ~ "BSSL",
    "NB-SB" ~ "BSSL",
    .default = "Other"
  ))
```

```{r}
dist_BSSL <- tecbound %>%
  filter(NiceName == "BSSL") %>%
  st_union() %>%
  st_distance(s4df) %>%
  drop() %>%
  units::drop_units()
s4df <- s4df %>%
  mutate(dist = dist_BSSL)
```

## Strike of BSSL
The strike (up to $\pm \pi$) of the faults at the closest point to each earthquake.

First need to split the faults into segments
```{r}
tecbound_interest <- tecbound %>%
  filter(NiceName == "BSSL")
teccoords <- tecbound_interest %>%
  st_coordinates()
strike <- teccoords %>%
  as_tibble() %>%
  tibble::rowid_to_column() %>%
  st_as_sf(coords = c("X", "Y"), crs = st_crs(tecbound)) %>%
  lwgeom::st_geod_azimuth() %>%
  units::drop_units()
# make strike between 0 and 2pi
strike[which(strike < 0)] <- strike[which(strike < 0)] + 2*pi
# get segments as sf objects
segs <- cbind(teccoords[-nrow(teccoords), c("X", "Y")], teccoords[-1, c("X", "Y")]) %>%
  apply(1, function(vec){
    st_linestring(matrix(vec, 2, 2, byrow = TRUE))
  }, simplify = FALSE) %>%
  st_as_sfc(crs = st_crs(tecbound))
segs <- st_sf(strike = strike, fault = teccoords[-nrow(teccoords), "L1"], geometry = segs)
# remove the bearings corresponding to jumping between faults
segs <- segs[teccoords[-nrow(teccoords), "L1"] - teccoords[-1, "L1"] >= -0.5, ]

# L1 refers to the feature so can get back to plate names etc
segs$FaultName <- tecbound_interest$Name[segs$fault]
segs$NiceName <- tecbound_interest$NiceName[segs$fault]
```


```{r}
segs <- segs %>%
   mutate(strike = case_when(strike > pi ~ strike - pi,
                             TRUE ~ strike))
```

```{r}
#| fig.width: 8
#| fig.height: 2
segs %>%
  # mutate(strike = cut(strike, c(0,1.7,2.5, pi), include.lowest = TRUE)) %>%
  ggplot() +
  geom_sf(aes(col = strike), linewidth = 2) +
  scale_color_viridis_c() +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
```
Find closest segment to each earthquake and use that for strike.
```{r}
segidx <- st_nearest_feature(s4df, segs)
strike_BSSL <- segs$strike[segidx, drop = TRUE]
s4df <- bind_cols(s4df, fstrike = strike_BSSL)
```

Below plots the assigned fault's strike (`fstrike`) closest to each earthquake

```{r}
#| fig.width: 8
#| fig.height: 2
segs %>%
  ggplot() +
  geom_sf(aes(col = strike), linewidth = 2) +
  geom_point(data = s4df,
    aes(x = Longitude, y = Latitude, fill = fstrike), 
    shape = 21,
    show.legend = FALSE) +
  scale_color_viridis_c(name = "Strike", limits = range(segs$strike)) +
  scale_fill_viridis_c(name = "Strike", limits = range(segs$strike)) +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
```

Strike looks correct.

```{r}
#| fig.width: 8
#| fig.height: 2
ggplot() +
  geom_sf(data = world) +
  geom_point(data = s4df, aes(x = Longitude, y = Latitude, col = dist/1000)) +
  geom_sf(show.legend = FALSE, data = filter(tecbound, NiceName == "BSSL")) +
  theme_bw() +
  scale_color_viridis_c(name = "Distance (km)", transform = "log10") +
  theme(axis.title = element_blank()) +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
```


# SI Fig: Look for Outliers
Here I'll look for outliers, with the aim of obtaining a very clean data set for demonstration.
I'll view the moment tensors orthogonally projected onto axes determined by the first and second moment of the data such that
 the mean moment tensor has `Y1=1` and the covariance of the data in `Y2`...`Y5` coordinates is diagonal.
 The moment tensors according to these axes are obtained using `sphm:::standardise_sph()`.

```{r}
ystd <- s4df %>%
  st_drop_geometry() %>%
  select(s1, s2, sMrt, sMrf, sMtf) %>% 
  as.matrix() %>% 
  sphm:::standardise_sph()
colnames(ystd) <- paste0("Y", 1:5)
```


In the below plot, moment tensors of earthquakes on $S^4$ are orthogonally projected onto pairs of axes.
Point colour is given by earthquake longitude.
Background colour is the average earthquake longitude for that part of projected $S^4$.

The identified outliers are labelled.

```{r}
#| fig.width: 12
#| fig.height: 13

outliers <- c(
  "182" = "general",
  "306" = "general",
  "76" = "general",
  "254" = "general",
  "169" = "general",
  "87" = "general",
  "175" = "longitude",
  "260" = "longitude"
)
outliers <- outliers %>%
  tibble::enframe(name = "Number", value = "outlier") %>%
  mutate(Number = as.integer(Number))

s4df %>%
  st_drop_geometry() %>%
  mutate(stdcoords = as_tibble(sphm:::standardise_sph(as.matrix(across(c(s1, s2, sMrt, sMrf, sMtf)))), .name_repair = "minimal")) %>%
  tidyr::unnest_wider(stdcoords, names_sep = "") %>%
  rename_with(~gsub("stdcoords", "Y", .)) %>%
  left_join(outliers, by = "Number") %>%
  pivot_coordpairs(coordnames = paste0("Y", 1:5)) %>%
  pairedplotggprep() +
  stat_summary_2d(fun = mean,
                    aes(z = Longitude, fill = after_stat(value)),
                  bins = 10) +
  scale_fill_viridis_c(name = "Longitude") +
  geom_point(aes(fill = Longitude), size = 2, shape = 21) +
  ggrepel::geom_label_repel(aes(label = Number,
                                col = as.factor(outlier)),
                            data = ~filter(.x, !is.na(outlier)),
                            label.padding = 0.1,
                            min.segment.length = 0,
                            box.padding = 1,
                            show.legend = FALSE) +
  scale_colour_manual(values = c("black", "grey"))
```

From these plots we can see 6 earthquakes very different to the rest in at least some of the coordinates Y1 - Y5.
Earthquakes 182, 306, 76, 87 and 169 were outlying in Y1.
Earthquake 254 is an outlier in Y5.
Furthermore, earthquake 175 and to a lesser extent, earthquake 260, have high longitude, but have moment tensors close to low longitude earthquakes.


There also appears to be a shift in earthquake moment tensors with longitude < 148 (blue) vs other earthquakes (green-yellow), which we will incorporate into regression later.


# Remove Outliers
The outliers by region are:
```{r}
outliers <- outliers %>% #remove duplicates
  group_by(Number) %>%
  summarise(outlier = paste0(outlier, collapse = ","))

s4df %>%
  left_join(outliers, by = "Number") %>%
  filter(!is.na(outlier)) %>%
  st_drop_geometry() %>%
  select(Number, region, outlier) %>%
  arrange(region)
```


```{r}
s4df_clean <- s4df %>%
  left_join(outliers, by = "Number") %>%
  filter(is.na(outlier) | outlier == "depth" | outlier == "distance" |
           outlier == "fstrike") %>%
  mutate(outlier = case_when(Number == 93 ~ "possible", TRUE ~ outlier))
nrow(s4df_clean)
s4df_clean$Depth %>% as.factor() %>% summary()
```

# Main Figure: Earthquake Locations
```{r}
#| fig.width: 7
#| fig.height: 2
ggplot() +
  geom_sf(data = world) +
  geom_point(data = s4df %>% left_join(outliers, by = "Number"),
             aes(x = Longitude, y = Latitude, shape = is.na(outlier) | outlier == "depth" | outlier == "distance" |
           outlier == "fstrike"),
             position = position_jitter(width = 0.05, height = 0.05, seed = 1),
             show.legend = FALSE) +
  scale_shape_manual(values = c(4, 16)) +
  geom_sf(data = tecbound %>% filter(NiceName !="Other"), aes(lty = NiceName), show.legend = FALSE) +
  # geom_sf(data = regions %>% filter(region %in% 2:4), fill = NA, show.legend = FALSE) +
  scale_linetype_manual(values = c(NGT = "dashed", BSSL = "solid", Other = "dotted")) +
  theme_bw() +
  theme(axis.title = element_blank()) +
  coord_sf(xlim = c(144.0, 153), ylim = c(-4.5, -2))
ggsave("earthquakelocations.pdf", width = 7, height = 2)
```


Caption: Shallow earthquake locations near the Bismarck Sea Seismic Lineation (solid line).
Some jitter has been introduced because
`r s4df %>% select(Latitude, Longitude) %>% duplicated() %>% sum()` are colocated.

# Build covariates
Since dip has only two values 30 or 90, use it has a categorical variable.
Scale and center all Euclidean covariates to have mean 0 and sd of 1.

```{r}
xe <- s4df_clean %>%
  st_drop_geometry() %>%
  select(fstrike,
         Latitude,
         Longitude
         ) %>%
  mutate(Longitude.L148 = (Longitude > 148) * Longitude) %>%
  as.matrix()
xestd <- xe %>%
  scale() |>
  as_tibble()
cor(xestd)
```

# SvMF Regression: G01 = free
```{r}
mod_SvMF <- mobius_SvMF(s4df_clean %>% 
                        select(s1, s2, sMrt, sMrf, sMtf) %>% 
                        st_drop_geometry() %>% 
                        as.matrix(),
                      xs = NULL, 
                      xe = xestd %>% as.matrix(),
                      type = "Shogo",
                      G01behaviour = "free")
mod_SvMF$k
mod_SvMF$AIC
mod_SvMF$a
mod_SvMF$DoF
```

## Random Starts
```{r}
restarts <- pbapply::pblapply(1:100, function(seed){
  # randomly generates a Kassel-form link
  start <- sphm:::rmnlink_cann(p = 5, qs = 0, qe = ncol(xestd) + 2, preseed = seed)
  # convert to Shogo form:
  set.seed(seed+1)
  Qe <- mclust::randomOrthogonalMatrix(ncol(xestd)+1, 5-1)
  bigQe <- cbind(0, rbind(0, Qe))
  bigQe[, 1] <- 0
  bigQe[1,1] <- 1
  start$Qe <- bigQe
  start$ce <- 1
  mobius_SvMF(s4df_clean %>% 
                          select(s1, s2, sMrt, sMrf, sMtf) %>% 
                          st_drop_geometry() %>% 
                          as.matrix(),
                      xs = NULL, 
                      xe = xestd %>% as.matrix(),
                      type = "Shogo",
                      G01behaviour = "free",
                      mean = start)
}, cl = 2)
badrestarts <- unlist(lapply(restarts, inherits, "try-error"))
restarts <- restarts[!badrestarts]
lapply(restarts, "[[", "AIC") %>%
  unlist() %>%
  tibble::enframe("seed", "AIC") %>%
  ggplot()+
  geom_freqpoly(aes(x = AIC), bins = 30) +
  geom_vline(xintercept = mod_SvMF$AIC, col = "blue") +
  geom_rug(aes(x = AIC))
```

```{r}
idx <- which.min(lapply(restarts, "[[", "AIC") %>% unlist())
all.equal(restarts[[idx]][c("mean", "k", "a", "G0", "AIC")], mod_SvMF[c("mean", "k", "a", "G0", "AIC")])
```

```{r}
idx <- which.min(lapply(restarts, "[[", "AIC") %>% unlist())
mod_SvMF <- restarts[[idx]]
mod_SvMF$k
mod_SvMF$AIC
mod_SvMF$a
mod_SvMF$DoF
sphm:::SvMFcann_check(sphm:::SvMFcann(mod_SvMF$k, mod_SvMF$a, mod_SvMF$G0))
```

```{r}
cann <- sphm:::as_mnlink_cann(mod_SvMF$mean)
cann$Be
t(cann$Qe[,-1])
cann$Be %*% t(cann$Qe[,-1])
cann$P
```

## Singularity Angles
Angle with p1:
```{r}
range(acos(mod_SvMF$pred %*% mod_SvMF$mean$p1))
```

Angle with G01:
```{r}
range(acos(mod_SvMF$pred %*% mod_SvMF$G0[,1]))
```

## Prediction Paired Plot
```{r}
get_predobspairsdf <- function(mod,
                               extra = NULL,
                               colpairs = combn(paste0("Y",1:5), 2, simplify = FALSE),
                               useG0 = FALSE){
  # standard rotations
  if (useG0){
    ystd <- standardise_sph(mod$y, tG = t(mod$G0))
  } else {
    ystd <- standardise_sph(mod$y)
  }
  
  colnames(ystd) <- paste0("Y", 1:ncol(ystd))
  predstd <- standardise_sph(mod$pred, attr(ystd, "std_rotation"))
  colnames(predstd) <- paste0("p_Y", 1:ncol(predstd))
  # apply to p1 too
  p1std <- standardise_sph(matrix(mod$mean$p1, nrow = 1), attr(ystd, "std_rotation"))
  colnames(p1std) <- paste0("Y", 1:ncol(ystd))
  p1pairs <- as_tibble(p1std) %>%
    pivot_coordpairs(colpairs = colpairs)
  # apply to G0 too
  # first get start and end location of pretty axes around G01
  arrowends <- t(t(mod$G0[,-1] - mod$G0[,1]) * mod$a[-1]/10) + mod$G0[,1] # convert to difference, scale difference by scales a, add start back
  colnames(arrowends) <- paste0("G0", 1+ (1:ncol(arrowends)))
  
  axisarrows <- lapply(1:nrow(mod$pred), function(idx){
    pred <- mod$pred[idx, ]
    # rotate (parallel transport) arrows to be around predicted mean, then rotate again for standardised coordinates
    stdarrowends <- attr(ystd, "std_rotation") %*% sphm:::rotationmat_amaral(mod$G0[,1], pred) %*% arrowends
    rownames(stdarrowends) <- paste0("Y", 1:ncol(ystd))
    # include start location too
    stdpred <- drop(attr(ystd, "std_rotation") %*% pred)
    names(stdpred) <- paste0("start", rownames(stdarrowends))
    as_tibble(t(stdarrowends), rownames = "Axis") %>%
      bind_cols(t(stdpred)) %>%
      bind_cols(extra[idx, ])
  }) %>%
    bind_rows()
  # apply orthogonal projections
  axisarrows_pairs <- lapply(colpairs, function(pair) {
    axisarrows %>%
      select(everything(), -starts_with("Y"), -starts_with("startY"), all_of(pair), all_of(paste0("start", pair))) %>%
      rename(A = last_col(3), B = last_col(2), startA = last_col(1), startB = last_col(0)) %>%
      mutate(pair1=pair[1],
             pair2=pair[2],
             pair = paste(pair, collapse = "-"))
  }) %>%
    bind_rows()

  # old G0 axes
  G0std <- attr(ystd, "std_rotation") %*% mod$G0
  rownames(G0std) <- paste0("Y", 1:ncol(ystd))
  colnames(G0std) <- paste0("G0", 1:ncol(G0std))
  G0pairs <- as_tibble(t(G0std), rownames = "Axis") %>%
    pivot_coordpairs(colpairs = colpairs)
  
  predsobs <- bind_cols(predstd,
                        ystd,
                        extra)
  pair_dfs <- lapply(colpairs, function(pair) {
    predsobs %>%
      select(everything(), -starts_with("Y"), -starts_with("p_Y"), all_of(pair),all_of(paste0("p_", pair))) %>%
      rename(A = last_col(3), B = last_col(2), p_A = last_col(1), p_B = last_col(0)) %>%
      mutate(pair1=pair[1],
             pair2=pair[2],
             pair = paste(pair, collapse = "-"))
  })
  pairsdf <- bind_rows(pair_dfs)
  attr(pairsdf, "p1") <- p1pairs
  attr(pairsdf, "G0") <- G0pairs
  attr(pairsdf, "Garrows") <- axisarrows_pairs
  attr(pairsdf, "coordnames") <- paste0("Y",1:5)
  pairsdf
}
```

```{r}
getG0arrows <- function(mod_SvMF){
  names(mod_SvMF$a) <- paste0("G0", 1:length(mod_SvMF$a))
  tibble::enframe(mod_SvMF$a, name = "Axis", value = "scale")
  orientations <- get_predobspairsdf(mod_SvMF) %>%
    attr("G0") %>%
    left_join(tibble::enframe(mod_SvMF$a, name = "Axis", value = "scale"), by = "Axis") %>%
    # mutate(across(c(A, B, starts_with("Y")), ~case_when(Axis != "G01" ~ .x * scale/20, TRUE ~ .x))) #scale axes by their estimated scale, except G01
    group_by(pair) %>%
    arrange(Axis) %>%
    select(-starts_with("Y")) %>%
    mutate(
      Astart = first(A),
      Bstart = first(B),
      A = A - Astart,
      B = B - Bstart) %>% #make everything vectors - works because projection orthogonal
      # across(c(A, B), ~.x - first(.x))) %>% #make everything vectors - works because projection orthogonal
    mutate(across(c(A, B), ~.x * scale/10)) %>% #scale axes by their estimated scale (G01 is 0 currently so scaling it does nothing)
    filter(Axis != "G01") %>%
    ungroup() %>%
    # add G01 back into A B etc
    mutate(A = A + Astart, B = B + Bstart)
  return(orientations)
}
```

```{r}
#| fig.width: 15
#| fig.height: 13
defaultplot_pred <- function(mod_SvMF, s4df_clean, focusaxes = FALSE, focusresponse = FALSE){
  plotobj <- get_predobspairsdf(mod_SvMF, bind_cols(s4df_clean, rdist = mod_SvMF$dists, rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x)))) %>%
    pairedplotggprep() 
  if (!focusaxes){
    plotobj <- plotobj %>%
      addaxes(mod_SvMF, axiscolour = rep("grey", 4), alpha = 0.5)
  }
  if (focusresponse){
    plotobj <- plotobj +
      geom_point(aes(x=A, y=B, col = Longitude), size = 2)
  } else {
    plotobj <- plotobj +
      geom_point(aes(x=p_A, y=p_B, col = Longitude), size = 2)
  }
  plotobj <- plotobj +
    geom_point(aes(x=A, y=B), size = 2, col = "blue",
               data = attr(get_predobspairsdf(mod_SvMF), "p1")) +
    geom_point(aes(x=-A, y=-B), size = 2, col = "blue", shape = 21,
               data = attr(get_predobspairsdf(mod_SvMF), "p1")) +
    geom_point(aes(x=A, y=B), size = 2, col = "red",
               data = attr(get_predobspairsdf(mod_SvMF), "G0") %>% filter(Axis == "G01")) +
    geom_segment(aes(x=Astart,y=Bstart, xend=A, yend=B),
                 data = getG0arrows(mod_SvMF) %>% filter(Axis == "G02"),
                 arrow = grid::arrow(length = unit(0.02, "npc"))) +
    geom_segment(aes(x=Astart,y=Bstart, xend=A, yend=B),
                 col = "grey",
                 data = getG0arrows(mod_SvMF) %>% filter(Axis == "G03"),
                 arrow = grid::arrow(length = unit(0.02, "npc"))) +
    geom_point(aes(x=-A, y=-B), size = 2, col = "red", shape = 21,
               data = attr(get_predobspairsdf(mod_SvMF), "G0") %>% filter(Axis == "G01")) +
    geom_segment(aes(x=p_A, y=p_B, xend=A, yend=B, col = Longitude),
                 alpha = 0.5,
                  arrow = grid::arrow(length = unit(0.02, "npc"))) +
    scale_color_viridis_c() +
    ggtitle("Prediction Highlighted")
  if (focusaxes){
    plotobj <- plotobj %>%
      addaxes(mod_SvMF, axiscolour = c("red", "green", "blue", "purple")) 
  }
  return(plotobj)
}
addaxes <- function(plotobj, mod_SvMF, axiscolour = c("red", "green", "blue", "purple"), alpha = 1){
  plotobj +
    geom_segment(aes(x=startA,y=startB, xend=A, yend=B),
                 data = attr(get_predobspairsdf(mod_SvMF), "Garrows") %>% filter(Axis == "G02"),
                 alpha = alpha,
                 col = axiscolour[1]) +
                 # arrow = grid::arrow(length = unit(0.02, "npc"), type = "closed")) +
    geom_segment(aes(x=startA,y=startB, xend=A, yend=B),
                 data = attr(get_predobspairsdf(mod_SvMF), "Garrows") %>% filter(Axis == "G03"),
                 alpha = alpha,
                 col = axiscolour[2]) +
                 # arrow = grid::arrow(length = unit(0.02, "npc"), type = "closed")) +
    geom_segment(aes(x=startA,y=startB, xend=A, yend=B),
                 data = attr(get_predobspairsdf(mod_SvMF), "Garrows") %>% filter(Axis == "G04"),
                 alpha = alpha,
                 col = axiscolour[3]) +
                 # arrow = grid::arrow(length = unit(0.02, "npc"), type = "closed")) +
    geom_segment(aes(x=startA,y=startB, xend=A, yend=B),
                 data = attr(get_predobspairsdf(mod_SvMF), "Garrows") %>% filter(Axis == "G05"),
                 alpha = alpha,
                 col = axiscolour[4])
                 # arrow = grid::arrow(length = unit(0.02, "npc"), type = "closed")) 
}
defaultplot_pred(mod_SvMF, s4df_clean)
defaultplot_pred(mod_SvMF, s4df_clean, focusaxes = TRUE)
```


## Residuals
Here we plot the the residuals against each of the axes defined by $\Gamma_0$. We can see the ellipsiodal nature of Scaled von Mises Fisher residuals.

```{r}
#| fig.width: 8
#| fig.height: 7
defaultplot_resid <- function(mod_SvMF, s4df_clean){
  mod_SvMF$rresids_G0 %>%
    as_tibble() %>%
    bind_cols(s4df_clean, rdist = mod_SvMF$dists) %>%
    bind_cols(rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x))) %>%
    pivot_coordpairs(coordnames = paste0("r", 1:4)) %>%
    pairedplotggprep() +
    stat_summary_2d(fun = mean, 
                    aes(z = Longitude, fill = after_stat(value)),
                    bins = 10) +
    geom_point(aes(fill = Longitude), size = 2, shape = 21) +
    scale_fill_viridis_c(name = "Longitude") +
    scale_color_viridis_c(name = "Longitude")
}
defaultplot_resid(mod_SvMF, s4df_clean)
```

## Standardised Residuals
Below the same residuals are transformed using the estimated concentration and Scale von Mises Fisher scales so that at high-concentrations the residuals should be close to a standard multivariate Normal.

```{r}
#| fig.width: 6
#| fig.height: 5
defaultplot_srresid <- function(mod_SvMF, s4df_clean){
mod_SvMF$rresids_std %>%
  as_tibble() %>%
  bind_cols(s4df_clean, rdist = mod_SvMF$dists) %>%
  pivot_coordpairs(coordnames = paste0("r", 1:4)) %>%
  ggplot(mapping = aes(x=A, y=B, col = fstrike)) + 
  facet_wrap(vars(pair2, pair1)) +
  theme(strip.text.y = element_text(angle = 90),
        strip.placement = "outside",
        axis.title = element_blank(),
        strip.background = element_blank()) +
  geom_hline(yintercept = 0, lty = "dashed") +
  geom_vline(xintercept = 0, lty = "dashed") +
  geom_point(size = 1) +
  scale_color_viridis_c() +
  coord_fixed()
}
defaultplot_srresid(mod_SvMF, s4df_clean)
```

## Standardised Residual Distance
```{r}
#| fig.width: 5
#| fig.height: 2
defaultplot_srresid_dist <- function(mod_SvMF, s4df_clean){
stdrdist <- sqrt(rowSums(mod_SvMF$rresids_std^2))
stdrdist[!attr(mod_SvMF$rresids_std, "samehemisphere")] <- NA_real_
p1 <- bind_cols(srdist = stdrdist, rdist = mod_SvMF$dists, s4df_clean) %>%
  bind_cols(rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x))) %>%
  ggplot(aes(y=srdist, x = Longitude)) +
  geom_point() 

p2 <- bind_cols(srdist = stdrdist, rdist = mod_SvMF$dists, s4df_clean) %>%
  bind_cols(rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x))) %>%
  ggplot(aes(y=srdist, x = fstrike)) +
  geom_point() 

p1 + p2
}
defaultplot_srresid_dist(mod_SvMF, s4df_clean)
```

## Residual Distance (Unstandardised)
```{r}
#| fig.width: 5
#| fig.height: 2
defaultplot_rresid_dist <- function(mod_SvMF, s4df_clean){
p1 <- bind_cols(rdist = mod_SvMF$dists, s4df_clean) %>%
  bind_cols(rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x))) %>%
  ggplot(aes(y=rdist, x = Longitude)) +
  geom_point()

p2 <- bind_cols(rdist = mod_SvMF$dists, s4df_clean) %>%
  bind_cols(rename_with(as_tibble(mod_SvMF$rresids_std), ~paste0("std", .x))) %>%
  ggplot(aes(y=rdist, x = fstrike)) +
  geom_point()

p1 + p2
}
defaultplot_rresid_dist(mod_SvMF, s4df_clean)
```

## Residual Mean by Covariates
```{r}
defaultplot_residbycovar <- function(mod_SvMF, s4df_clean){
bind_cols(mod_SvMF$rresids_G0, s4df_clean) %>%
  st_drop_geometry() %>%
  tidyr::pivot_longer(matches("^r.$"), names_to = "raxis", values_to = "value") %>%
  tidyr::pivot_longer(c(Longitude, fstrike, dist, Depth), names_to = "covariate", values_to = "cvalue") %>%
  filter(!(covariate == "dist" & (cvalue > 50000))) %>%
  ggplot(aes(x = cvalue, y = value)) +
  facet_grid(rows = vars(raxis), cols = vars(covariate), scales = "free") +
  geom_hline(yintercept = 0, col = "blue", lty = "dashed") +
  geom_smooth(method = "loess", formula = 'y ~ x', data = ~filter(.x, covariate != "Depth")) +
  geom_point() +
  stat_summary(fun.data = mean_se, geom = "errorbar", width = 1.5, col = "blue", data = ~filter(.x, covariate == "Depth"))
}
defaultplot_residbycovar(mod_SvMF, s4df_clean)
```


## Conclusion
Model looks good. Even `rdist`.


# Predictions in Natural Coordinates

```{r}
get_predobspairsdf_nat <- function(mod,
                               extra = NULL,
                               colpairs = combn(c("s1", "s2", "sMrt", "sMrf", "sMtf"), 2, simplify = FALSE)){
  # apply to p1 too
  p1pairs <- tibble::as_tibble_row(mod$mean$p1) %>%
    pivot_coordpairs(colpairs = colpairs)
  
  # apply to G0 too
  # first get start and end location of pretty axes around G01
  arrowends <- t(t(mod$G0[,-1] - mod$G0[,1]) * mod$a[-1]/10) + mod$G0[,1] # convert to difference, scale difference by scales a, add start back
  colnames(arrowends) <- paste0("G0", 1+ (1:ncol(arrowends)))
  
  axisarrows <- lapply(1:nrow(mod$pred), function(idx){
    pred <- mod$pred[idx, ]
    # rotate (parallel transport) arrows to be around predicted mean
    arrowends <- sphm:::rotationmat_amaral(mod$G0[,1], pred) %*% arrowends
    # include start location too
    names(pred) <- paste0("start", rownames(arrowends))
    as_tibble(t(arrowends), rownames = "Axis") %>%
      bind_cols(t(pred)) %>%
      bind_cols(extra[idx, ])
  }) %>%
    bind_rows()
  # apply orthogonal projections
  axisarrows_pairs <- lapply(colpairs, function(pair) {
    axisarrows %>%
      select(everything(), -starts_with("s"), -starts_with("starts"), all_of(pair), all_of(paste0("start", pair))) %>%
      rename(A = last_col(3), B = last_col(2), startA = last_col(1), startB = last_col(0)) %>%
      mutate(pair1=pair[1],
             pair2=pair[2],
             pair = paste(pair, collapse = "-"))
  }) %>%
    bind_rows()
  
  # old G0 axes
  colnames(mod$G0) <- paste0("G0", 1:ncol(mod$G0))
  G0pairs <- as_tibble(t(mod$G0), rownames = "Axis") %>%
    pivot_coordpairs(colpairs = colpairs)
  
  predsobs <- bind_cols(mod$pred %>%
                          as_tibble() %>%
                          rename_with(~paste0("p_", .)),
                        mod$y,
                        extra)
  pair_dfs <- lapply(colpairs, function(pair) {
    predsobs %>%
      select(everything(), -starts_with("s"), -starts_with("p_s"), all_of(pair),all_of(paste0("p_", pair))) %>%
      rename(A = last_col(3), B = last_col(2), p_A = last_col(1), p_B = last_col(0)) %>%
      mutate(pair1=pair[1],
             pair2=pair[2],
             pair = paste(pair, collapse = "-"))
  })
  pairsdf <- bind_rows(pair_dfs)
  attr(pairsdf, "p1") <- p1pairs
  attr(pairsdf, "G0") <- G0pairs
  attr(pairsdf, "Garrows") <- axisarrows_pairs
  attr(pairsdf, "coordnames") <- c("s1", "s2", "sMrt", "sMrf", "sMtf")
  pairsdf
}
```

```{r}
#| fig.width: 15
#| fig.height: 13
get_predobspairsdf_nat(mod_SvMF, s4df_clean %>% select(-starts_with("s"))) %>%
  pairedplotggprep() +
  geom_segment(aes(x=p_A, y=p_B, xend=A, yend=B, col = Longitude),
               alpha = 0.5,
                arrow = grid::arrow(length = unit(0.02, "npc"))) +
  geom_point(aes(x=p_A, y=p_B, col = Longitude), size = 2) +
  geom_point(aes(x=A, y=B), size = 2, col = "blue",
             shape = 4,
             data = attr(get_predobspairsdf_nat(mod_SvMF), "p1")) +
  scale_color_viridis_c() +
  ggtitle("Prediction Highlighted: natural coords")
```



# Paper Plot
```{r}
obsplots <- lapply(c("Y1-Y2", "Y3-Y2", "Y4-Y2"), function(pair){
  get_predobspairsdf(mod_SvMF, s4df_clean,
                     colpairs = strsplit(pair, "-")) %>%
    pairedplotggprep() +
    geom_point(aes(x=A, y=B, col = Longitude), size = 1) +
    scale_color_viridis_c() +
    theme(plot.margin = unit(c(0,2,0,2), "mm"),
          strip.text = element_text(margin = margin(0, 0, 0, 0)))
})
# choose earthquakes to mark orientation axes
axesmarked <- c(225, 217, 86, 89, 218, 54) #ends of Longitude bins [.,148], [148,.] and middles
#arrange(s4df_clean, Longitude)$Number[seq(1, nrow(s4df_clean), by = 5)]

predplots <- lapply(c("Y1-Y2", "Y3-Y2", "Y4-Y2"), function(pair){
  paireddf <- get_predobspairsdf(mod_SvMF, s4df_clean,
                     colpairs = strsplit(pair, "-"))
  paireddf %>%
  pairedplotggprep() +
  # ggrepel::geom_text_repel(aes(x=p_A, y=p_B, label = Number), size = 1, min.segment.length = 0) +
  geom_segment(aes(x=startA,y=startB, xend=A, yend=B),
                 data = ~attr(paireddf, "Garrows") %>% filter(pair %in% .x$pair) %>% filter(Number %in% axesmarked),
                 alpha = 1,
                 col = "grey") +
  geom_segment(aes(x=p_A, y=p_B, xend=A, yend=B, col = Longitude),
               alpha = 1,
                arrow = grid::arrow(length = unit(0.02, "npc"))) +
  geom_point(aes(x=p_A, y=p_B, fill = Longitude),
             size = 1.5,
             shape = 21) +
  geom_point(aes(x=A, y=B), size = 2, col = "blue",
             shape = 21,
             data = ~attr(paireddf, "G0") %>% filter(Axis == "G01") %>% filter(pair == "Y1-Y2")) +
  geom_point(aes(x=A, y=B), size = 2, col = "blue",
             shape = 4,
             data = ~(attr(paireddf, "p1") %>% filter(pair == "Y1-Y2"))
             ) +
  scale_color_viridis_c() +
  scale_fill_viridis_c() +
  theme(plot.margin = unit(c(0,2,0,2), "mm"),
          strip.text = element_text(margin = margin(0, 0, 0, 0)))
})
( (obsplots[[1]] + 
     (obsplots[[2]]) + 
     (obsplots[[3]]) )/
  (predplots[[1]] + 
     (predplots[[2]]) + 
     (predplots[[3]])) ) + 
  plot_layout(guides = "collect") + 
  theme(legend.position = "bottom")
```


Caption: 42 normalised earthquake moment tensors on $S^4$.
Moment tensors are shown orthoganally projected onto pairs of axes that standardise the observed earthquake moments to have mean of (1,0,0,0,0) with axes of variation Y2, Y3, Y4 and Y5 ordered by decreasing variance.
Plots of projections onto further pairs of axes are in SI.
Top: Observed earthquake moment tensors.
Bottom: Mean earthquake moment tensors according to our regression.
Colour: Longitude of earthquakes.
Arrows: represent residuals and point from mean earthquake moment tensor to the corresponding observed earthquake moment tensor.
Blue x: The location of the first column of $B_0$.
Grey circle boundary: intersection of $S^4$ with the plane given by the pair of axes.

# Paper Plot 2
```{r}
obsplots <- get_predobspairsdf_nat(mod_SvMF, s4df_clean %>% select(-starts_with("s")),
                     colpairs = strsplit(c("s1-s2", "sMtf-s2", "sMrt-s2"), "-")) %>%
    pairedplotggprep() +
    geom_point(aes(x=A, y=B, col = Longitude), size = 1) +
    scale_color_viridis_c() +
    theme(plot.margin = unit(c(0,2,0,2), "mm"),
        axis.line.y = element_line(arrow = grid::arrow(type = "closed", angle = 10, length = unit(10, "points")),
                                 linewidth = 0.2),
          strip.text = element_text(margin = margin(0, 0, 0, 0), size = 8),
          strip.text.x.bottom = element_blank())

paireddf <- get_predobspairsdf_nat(mod_SvMF, s4df_clean %>% select(-starts_with("s")),
                     colpairs = strsplit(c("s1-s2", "sMtf-s2", "sMrt-s2"), "-"))
predplots <- paireddf %>%
  pairedplotggprep() +
  geom_segment(aes(x=p_A, y=p_B, xend=A, yend=B, col = Longitude),
               alpha = 1,
                arrow = grid::arrow(length = unit(0.02, "npc"))) +
  geom_point(aes(x=p_A, y=p_B, fill = Longitude),
             size = 1.5,
             shape = 21) +
  geom_point(aes(x=A, y=B), size = 2, col = "blue",
             shape = 21,
             data = ~attr(paireddf, "G0") %>% filter(Axis == "G01") %>% filter(pair %in% .x$pair)) +
  geom_point(aes(x=A, y=B), size = 2, col = "blue",
             shape = 4,
             data = ~(attr(paireddf, "p1") %>% filter(pair %in% .x$pair))
             ) +
  scale_color_viridis_c() +
  scale_fill_viridis_c() +
  theme(plot.margin = unit(c(0,2,0,2), "mm"),
        axis.line = element_line(arrow = grid::arrow(type = "closed", angle = 10, length = unit(10, "points")),
                                 linewidth = 0.2),
          strip.text = element_text(margin = margin(0, 0, 0, 0), size = 8))

obsplots/
  predplots + 
  plot_layout(guides = "collect")
ggsave("earthquake_results.pdf", width = 7, height = 4)
```

# Likelihood Ratio Test of vMF vs SvMF
First get best vMF model
```{r}
mod_vMF <- mobius_vMF(y = mod_SvMF$y,
                     xs = NULL, 
                     xe = mod_SvMF$xe,
                     type = "Shogo")
mod_vMF_restarts <- pbapply::pblapply(1:100, function(seed){sphm:::mobius_vFM_restart(mod_vMF, seed)})
lapply(mod_vMF_restarts, "[[", "AIC") %>%
  unlist() %>%
  tibble::enframe("seed", "AIC") %>%
  ggplot()+
  geom_freqpoly(aes(x = AIC), bins = 30) +
  geom_vline(xintercept = mod_vMF$AIC, col = "blue") +
  geom_rug(aes(x = AIC))
idx <- which.min(lapply(mod_vMF_restarts, "[[", "AIC") %>% unlist())
mod_vMF <- mod_vMF_restarts[[idx]]  
mod_vMF$k
mod_vMF$AIC
```

```{r}
getlikR <- function(y){
  mod1 <- mobius_vMF(y,
                     xs = NULL, 
                     xe = mod_vMF$xe,
                     type = "Shogo",
                     start = mod_vMF$est)
  mod2 <- withCallingHandlers({mobius_SvMF(y,
                      xs = NULL, 
                      xe = mod_vMF$xe,
                      type = "Shogo",
                      G01behaviour = "free",
                      mean = mod_SvMF$mean,
                      k = mod_SvMF$k,
                      a = mod_SvMF$a,
                      G0 = mod_SvMF$G0)},
        warning = function(w){
        if (grepl("p!=3", conditionMessage(w))) {
          invokeRestart("muffleWarning")
        }
      })
  lLik1 <- sphm:::dS2S_constV(mod1$y, xs = NULL, xe =mod1$xe,
              mean = mod1$est,
              k = mod1$k,
              a = rep(1, 5),
              G0 = mod2$G0) %>%
    colSums()
  lLik2 <- sphm:::dS2S_constV(mod2$y, xs = NULL, xe =mod2$xe,
              mean = mod2$mean,
              k = mod2$k,
              a = mod2$a,
              G0 = mod2$G0) %>%
    colSums()

  # I'm going to use the R version because it will calculate things more accurately
  list(likR = -2* (lLik1[["R"]] - lLik2[["R"]]),
       vMF = mod1,
       SvMF = mod2)
}
null_likRs <- pbapply::pblapply(1:1000, function(seed){
  set.seed(seed)
  y_ld <- sphm:::rS2S_constV(xs = NULL, 
                   xe = mod_vMF$xe,
                   mnparam = mod_vMF$mean,
                   k = mod_vMF$k,
                   a = rep(1, 5),
                   G0 = diag(1,5))
  sum(y_ld[,6])
  y <- y_ld[,-6]
  getlikR(y)
})
obs <- getlikR(s4df_clean %>% 
                        select(s1, s2, sMrt, sMrf, sMtf) %>% 
                        st_drop_geometry() %>% 
                        as.matrix())
```

P-value is the probability, under the null, of getting a likelihood-ratio that is at least as large as the observed ratio:

```{r}
mean(lapply(null_likRs, "[[", "likR") %>% unlist() > obs$likR)
```

The likelihood ratio is larger than any simulated data from the null (vMF model) achieves. Suggesting the data does not come from the vMF model.

# Parametric Bootstrap Regions for `a`
Since a vMF model is rejected, lets look at CI that for the fitted SvMF.

```{r}
Bests <- pbapply::pblapply(1:1000, function(seed){
  set.seed(seed)
  y <- sphm:::rS2S_constV(xs = NULL, 
                   xe = mod_SvMF$xe,
                   mnparam = mod_SvMF$mean,
                   k = mod_SvMF$k,
                   a = mod_SvMF$a,
                   G0 = mod_SvMF$G0)[,-6]
  newmod <- withCallingHandlers({mobius_SvMF(y,
                      xs = NULL, 
                      xe = mod_SvMF$xe,
                      type = "Shogo",
                      G01behaviour = "free",
                      mean = mod_SvMF$mean,
                      k = mod_SvMF$k,
                      a = mod_SvMF$a,
                      G0 = mod_SvMF$G0)},
          warning = function(w){
        if (grepl("p!=3", conditionMessage(w))) {
          invokeRestart("muffleWarning")
        }
      })
  return(newmod[c("mean", "k", "a", "G0")])
}, cl = 2)
```


```{r}
Bests_a <- lapply(Bests, "[[", "a") %>%
  simplify2array() %>%
  t()
colnames(Bests_a) <- paste0("a", 1:5)
summary(Bests_a)
```

### 95% CI for a
```{r}
apply(Bests_a[,-1], 2, quantile, probs = c(0.025, 0.975)) %>%
  round(2)
```

# CI via `boot` package
```{r}
set.seed(1)
bootres <- boot::boot(
  data = mod_SvMF$y,
  statistic = function(data){
    newmod <- withCallingHandlers({mobius_SvMF(data,
                    xs = NULL, 
                    xe = mod_SvMF$xe,
                    type = "Shogo",
                    G01behaviour = "free",
                    mean = mod_SvMF$mean,
                    k = mod_SvMF$k,
                    a = mod_SvMF$a,
                    G0 = mod_SvMF$G0)},
        warning = function(w){
      if (grepl("p!=3", conditionMessage(w))) {
        invokeRestart("muffleWarning")
      }
    })
    newmod$a[-1]
  },
  R = 1000,
  sim = "parametric",
  ran.gen = function(data, mle){
    sphm:::rS2S_constV(xs = NULL, 
                   xe = mod_SvMF$xe,
                   mnparam = mod_SvMF$mean,
                   k = mod_SvMF$k,
                   a = mod_SvMF$a,
                   G0 = mod_SvMF$G0)[,-6]
  }
)
```

```{r}
boot::boot.ci(bootres, type = c("perc"))
# boot::boot.ci(bootres, type = c("bca"))
```

# LOOCV MSE
```{r}
loocvmseSvMF <- function(mod){
  stopifnot(inherits(mod$mean, "mnlink_Omega"))
  dists <- pbapply::pblapply(1:nrow(mod$y), function(idx){
    newmod <- 
      withCallingHandlers({
      sphm:::optim_constV(mod$y[-idx,],
                xs = mod$xs[-idx,],
                xe = mod$xe[-idx,c(-1,-ncol(mod$xe)), drop = FALSE],
                fix_qs1 = FALSE,
                type = "Shogo",
                G01behaviour = "free",
                mean = mod$mean,
                k = mod$k,
                a = mod$a,
                G0 = mod$G0)},
      warning = function(w){
        if (grepl("p!=3", conditionMessage(w))) {
          invokeRestart("muffleWarning")
        }
      })
    pred <- mnlink(xs = mod$xs[idx,, drop = FALSE],
                   xe = mod$xe[idx,, drop = FALSE],
                   param = newmod$mean)
    obs <- mod$y[idx,]
    Euc <- sphm:::vnorm(drop(obs - pred))
    angle <- acos(rowSums(obs * pred))
    return(c(
      Euc = Euc,
      angle = angle
    ))
  })
  dists <- dists %>%
    simplify2array() %>%
    t() %>%
    as_tibble()
  dists %>%
    summarise(across(everything(), ~sum(.x^2)/nrow(mod$y)))
}
loocvmseSvMF(mod_SvMF)
```

More stable is to only do the `optim_constV()` step. MSE here is worse than the regional means.


# Discrete Mean Models
Instead of a regression, just use the regional mean, where regions defined by longitude.

```{r}
regionalmeans <- function(y, Longitude, breaks){
  y <- as_tibble(y)
  Longfctr <- cut(Longitude, breaks = breaks, include.lowest = TRUE, dig.lab = 4)
  groups <- split(y, Longfctr)
  means <- lapply(groups, function(df){
    mn <- colMeans(df)
    mn <- mn/sphm:::vnorm(mn)
    mn
  })
  return(list(means = means,
              y = y,
              Longitude = Longitude,
              breaks = breaks))
}
mod_3regions <- regionalmeans(
  y = s4df_clean %>%
  select(s1,s2,sMrt,sMrf,sMtf) %>%
  st_drop_geometry(),
  Longitude = s4df_clean$Longitude,
  breaks = c(144,147.3,150.3,152.5)
)
mod_2regions <- regionalmeans(
  y = s4df_clean %>%
  select(s1,s2,sMrt,sMrf,sMtf) %>%
  st_drop_geometry(),
  Longitude = s4df_clean$Longitude,
  breaks = c(144,148,152.5)
)
```

## LOOCV MSE
```{r}
loocvmseRegionMeans <- function(mod){
  dists <- pbapply::pblapply(1:nrow(mod$y), function(idx){
    newmod <- regionalmeans(y = mod$y[-idx,, drop = FALSE],
                            Longitude = mod$Longitude[-idx],
                            breaks = mod$breaks)
    # prediction
    region <- cut(mod$Longitude[idx], breaks = newmod$breaks, dig.lab = 4)
    pred <- newmod$means[[region]]
    obs <- unlist(as.vector(mod$y[idx,]))
    Euc <- sphm:::vnorm(drop(obs - pred))
    angle <- acos(sum(obs * pred))
    return(c(
      Euc = Euc,
      angle = angle
    ))
  })
  dists <- dists %>%
    simplify2array() %>%
    t() %>%
    as_tibble()
  dists %>%
    summarise(across(everything(), ~sum(.x^2)/nrow(mod$y)))
}
loocvmseRegionMeans(mod_3regions)
loocvmseRegionMeans(mod_2regions)
```


\appendix

# SvMF Regression: G01 = p1
```{r}
mod_SvMF <- mobius_SvMF(s4df_clean %>% 
                        select(s1, s2, sMrt, sMrf, sMtf) %>% 
                        st_drop_geometry() %>% 
                        as.matrix(),
                      xs = NULL, 
                      xe = xestd %>% as.matrix(),
                      type = "Shogo",
                      G01behaviour = "p1")
mod_SvMF$k
mod_SvMF$AIC
mod_SvMF$a
mod_SvMF$DoF
```

## Random Starts
```{r}
restarts <- pbapply::pblapply(1:100, function(seed){
  # randomly generates a Kassel-form link
  start <- sphm:::rmnlink_cann(p = 5, qs = 0, qe = ncol(xestd) + 2, preseed = seed)
  # convert to Shogo form:
  set.seed(seed+1)
  Qe <- mclust::randomOrthogonalMatrix(ncol(xestd)+1, 5-1)
  bigQe <- cbind(0, rbind(0, Qe))
  bigQe[, 1] <- 0
  bigQe[1,1] <- 1
  start$Qe <- bigQe
  start$ce <- 1
  mobius_SvMF(s4df_clean %>% 
                          select(s1, s2, sMrt, sMrf, sMtf) %>% 
                          st_drop_geometry() %>% 
                          as.matrix(),
                      xs = NULL, 
                      xe = xestd %>% as.matrix(),
                      type = "Shogo",
                      G01behaviour = "p1",
                      mean = start)
}, cl = 2)
badrestarts <- unlist(lapply(restarts, inherits, "try-error"))
restarts <- restarts[!badrestarts]
lapply(restarts, "[[", "AIC") %>%
  unlist() %>%
  tibble::enframe("seed", "AIC") %>%
  ggplot()+
  geom_freqpoly(aes(x = AIC), bins = 30) +
  geom_vline(xintercept = mod_SvMF$AIC, col = "blue") +
  geom_rug(aes(x = AIC))
```

```{r}
idx <- which.min(lapply(restarts, "[[", "AIC") %>% unlist())
all.equal(restarts[[idx]][c("mean", "k", "a", "G0", "AIC")], mod_SvMF[c("mean", "k", "a", "G0", "AIC")])
```


```{r}
idx <- which.min(lapply(restarts, "[[", "AIC") %>% unlist())
mod_SvMF <- restarts[[idx]]
mod_SvMF$k
mod_SvMF$AIC
mod_SvMF$a
mod_SvMF$DoF
sphm:::SvMFcann_check(sphm:::SvMFcann(mod_SvMF$k, mod_SvMF$a, mod_SvMF$G0))
```

```{r}
cann <- sphm:::as_mnlink_cann(mod_SvMF$mean)
cann$Be
t(cann$Qe[,-1])
cann$Be %*% t(cann$Qe[,-1])
cann$P
```

## Singularity Angles
Angle with p1:
```{r}
range(acos(mod_SvMF$pred %*% mod_SvMF$mean$p1))
```

Angle with G01:
```{r}
range(acos(mod_SvMF$pred %*% mod_SvMF$G0[,1]))
```

The model predictions do not get close to the antipode of p1 or the antipode of G01. This is good.

## Prediction Paired Plot

```{r}
#| fig.width: 15
#| fig.height: 13
defaultplot_pred(mod_SvMF, s4df_clean)
defaultplot_pred(mod_SvMF, s4df_clean, focusaxes = TRUE)
```


## Residuals
Here we plot the the residuals against each of the axes defined by $\Gamma_0$. We can see the ellipsiodal nature of Scaled von Mises Fisher residuals.

```{r}
#| fig.width: 8
#| fig.height: 7
defaultplot_resid(mod_SvMF, s4df_clean)
```

## Standardised Residuals
Below the same residuals are transformed using the estimated concentration and Scale von Mises Fisher scales so that at high-concentrations the residuals should be close to a standard multivariate Normal.

```{r}
#| fig.width: 6
#| fig.height: 5
defaultplot_srresid(mod_SvMF, s4df_clean)
```

## Standardised Residual Distance
```{r}
#| fig.width: 5
#| fig.height: 2
defaultplot_srresid_dist(mod_SvMF, s4df_clean)
```

## Residual Distance (Unstandardised)
```{r}
#| fig.width: 5
#| fig.height: 2
defaultplot_rresid_dist(mod_SvMF, s4df_clean)
```

## Residual Mean by Covariates
```{r}
defaultplot_residbycovar(mod_SvMF, s4df_clean)
```


## Conclusion
Model okay.

# SvMF Regression: G01 fixed
```{r}
ymean <- s4df_clean %>% 
  select(s1, s2, sMrt, sMrf, sMtf) %>% 
  st_drop_geometry() %>% 
  colMeans()
ymean <- ymean/sphm:::vnorm(ymean)
mod_SvMF <- mobius_SvMF(s4df_clean %>% 
                        select(s1, s2, sMrt, sMrf, sMtf) %>% 
                        st_drop_geometry() %>% 
                        as.matrix(),
                      xs = NULL, 
                      xe = xestd %>% as.matrix(),
                      type = "Shogo",
                      G01behaviour = "fixed",
                      G0 = cbind(ymean, NA, NA, NA, NA))
mod_SvMF$k
mod_SvMF$AIC
mod_SvMF$a
mod_SvMF$DoF
```

## Random Starts
```{r}
restarts <- pbapply::pblapply(1:100, function(seed){
  # randomly generates a Kassel-form link
  start <- sphm:::rmnlink_cann(p = 5, qs = 0, qe = ncol(xestd) + 2, preseed = seed)
  # convert to Shogo form:
  set.seed(seed+1)
  Qe <- mclust::randomOrthogonalMatrix(ncol(xestd)+1, 5-1)
  bigQe <- cbind(0, rbind(0, Qe))
  bigQe[, 1] <- 0
  bigQe[1,1] <- 1
  start$Qe <- bigQe
  start$ce <- 1
  mobius_SvMF(s4df_clean %>% 
                          select(s1, s2, sMrt, sMrf, sMtf) %>% 
                          st_drop_geometry() %>% 
                          as.matrix(),
                      xs = NULL, 
                      xe = xestd %>% as.matrix(),
                      type = "Shogo",
                      G01behaviour = "fixed",
                      G0 = cbind(ymean, NA, NA, NA, NA),
                      mean = start)
}, cl = 2)
badrestarts <- unlist(lapply(restarts, inherits, "try-error"))
restarts <- restarts[!badrestarts]
lapply(restarts, "[[", "AIC") %>%
  unlist() %>%
  tibble::enframe("seed", "AIC") %>%
  ggplot()+
  geom_freqpoly(aes(x = AIC), bins = 30) +
  geom_vline(xintercept = mod_SvMF$AIC, col = "blue") +
  geom_rug(aes(x = AIC))
```

```{r}
idx <- which.min(lapply(restarts, "[[", "AIC") %>% unlist())
all.equal(restarts[[idx]][c("mean", "k", "a", "G0", "AIC")], mod_SvMF[c("mean", "k", "a", "G0", "AIC")])
```

```{r}
idx <- which.min(lapply(restarts, "[[", "AIC") %>% unlist())
mod_SvMF <- restarts[[idx]]
mod_SvMF$k
mod_SvMF$AIC
mod_SvMF$a
mod_SvMF$DoF
sphm:::SvMFcann_check(sphm:::SvMFcann(mod_SvMF$k, mod_SvMF$a, mod_SvMF$G0))
```

```{r}
cann <- sphm:::as_mnlink_cann(mod_SvMF$mean)
cann$Be
t(cann$Qe[,-1])
cann$Be %*% t(cann$Qe[,-1])
cann$P
```

## Singularity Angles
Angle with p1:
```{r}
range(acos(mod_SvMF$pred %*% mod_SvMF$mean$p1))
```

Angle with G01:
```{r}
range(acos(mod_SvMF$pred %*% mod_SvMF$G0[,1]))
```

## Prediction Paired Plot

```{r}
#| fig.width: 15
#| fig.height: 13
defaultplot_pred(mod_SvMF, s4df_clean)
defaultplot_pred(mod_SvMF, s4df_clean, focusaxes = TRUE)
```


## Residuals
Here we plot the the residuals against each of the axes defined by $\Gamma_0$. We can see the ellipsiodal nature of Scaled von Mises Fisher residuals.

```{r}
#| fig.width: 8
#| fig.height: 7
defaultplot_resid(mod_SvMF, s4df_clean)
```

## Standardised Residuals
Below the same residuals are transformed using the estimated concentration and Scale von Mises Fisher scales so that at high-concentrations the residuals should be close to a standard multivariate Normal.

```{r}
#| fig.width: 6
#| fig.height: 5
defaultplot_srresid(mod_SvMF, s4df_clean)
```

## Standardised Residual Distance
```{r}
#| fig.width: 5
#| fig.height: 2
defaultplot_srresid_dist(mod_SvMF, s4df_clean)
```

## Residual Distance (Unstandardised)
```{r}
#| fig.width: 5
#| fig.height: 2
defaultplot_rresid_dist(mod_SvMF, s4df_clean)
```

## Residual Mean by Covariates
```{r}
defaultplot_residbycovar(mod_SvMF, s4df_clean)
```


## Conclusion
Model okay.


